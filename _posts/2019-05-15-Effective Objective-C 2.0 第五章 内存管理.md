---
layout:     post
title:      Effective Objective-C 2.0 第五章 内存管理
subtitle:   协议与分类
date:       2019-05-15
author:     Vergil
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - iOS
    - Effective Objective-C 2.0
---

## 第 29 条 理解引用计数

### 引用计数原理

引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1.若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。

在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。

### 属性存取方法中的内存管理

若属性 foo 由 strong 修饰，则其 set 方法会保留新值，释放旧值：

```
- (void)setFoo:(id)foo {
    [foo retain];
    [_foo release];
    _foo = foo;
}
```

### 自动释放池

autorelease 能延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。

自动释放池中的释放操作是在当前线程的下一次事件循环。

### 保留环

循环引用。

在垃圾收集环境中，通常将这种情况认定为"孤岛"(island of isolation)。此时，垃圾收集器会把三个对象全都回收走。而在Objective-C的引用计数架构中，则享受不到这一便利。通常采用"弱引用"(weak reference， 参见第33条)来解决此问题，或是从外界命令循环中的某个对象不再保留另外一个对象。这两种办法都能打破保留环，从而避免内存泄漏。

## 第 30 条 以 ARC 简化引用计数

- 有 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC  来编程，可省去类中的许多 “样板代码”。
- ARC 管理对象生命期的办法基本上就是：在合适的地方插入 “保留” 及 “释放”操作。
- 在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来需要手工执行 “保留” 及 “释放”操作。
- 由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC 将此确定为开发者必须遵守的规则。
- ARC 只负责管理 Objective-C  对象的内存。尤其要注意： CoreFoundation 对象不归 ARC  管理，开发者必须适时调用 CFRetain/CFRelease。

## 第 31 条 在 dealloc 方法中只释放引用并解除监听

- 在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观测”（KVO）或NSNotificationCenter等通知，不要做其他事情。
- 如果对象持有文件描述符等系统资源，那么应该专门写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法。
- 执行异步任务的方法不应该在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。

## 第 32 条 编写“异常安全代码”时留意内存管理问题

- 捕获异常时，一定要注意将try块内所创立的对象清理干净。

- 在默认情况下，ARC不生成安全处理一次所需的清理代码。开启编译器标志后（-fobjc-arc-exceptions）,可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。

## 第 33 条 以弱引用避免保留环

- 将某些引用设为weak，可避免出现“保留环”。
- weak引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着ARC而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过得对象。

## 第 34 条 以“自动释放池块”降低内存峰值

- 自动释放池排布在栈中,对象收到 autorelease 后,系统将其放入最顶端的池里。
- 合理运用自动释放池,能够降低应用程序的内存峰值。

## 第 35 条 用“僵尸对象”调试内存管理问题

- 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombieEnabled 可开启此功能。
- 系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使改对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。

## 第 36 条 不要使用 retainCount

在 MRC 下可以使用此方法查询对象的保留技术，ARC 环境下已经废弃此方法。

- 对象的保留计数看似有用，实则不然，因为任何给定时间点上的 '绝对保留计数' 都无法反映对象生命期的全貌。

- 引入 ARC 之后,retainCount 方法就正式废止了。在 ARC 下调用该方法会导致编译器报错。




 


