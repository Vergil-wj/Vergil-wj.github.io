<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vergil</title>
    <description>我用双手成就你的梦想！</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 26 May 2019 17:28:54 +0800</pubDate>
    <lastBuildDate>Sun, 26 May 2019 17:28:54 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>iOS NSCache 缓存</title>
        <description>&lt;p&gt;NSCache 是一个可变集合，即缓存。它存储key-value对，这一点类似于NSDictionary类。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NSCache 在系统内存很低时，会自动释放一些对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NSCache 是线程安全的，在多线程操作中，不需要对 Cache 加锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NSCache 的 Key 只是做强引用，不需要实现 NSCopying 协议&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;属性&quot;&gt;属性&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//缓存名
- @property (copy) NSString *name;

//缓存所能容纳最大总成本。
//默认为 0，没有限制。
//但需要注意的是，这不是一个严格的限制。如果缓存的数量超过这个数量，缓存中的一个对象可能会被立即丢弃、或者稍后、也可能永远不会，具体依赖于缓存的实现细节。
- @property NSUInteger totalCostLimit;	

//缓存对象最大数量。
//默认为 0，没有限制。
//被丢弃的对象的顺序无法保证，同totalCostLimit 限制策略一样。
- @property NSUInteger countLimit;	

//标示缓存是否回收废弃的内容。
//默认值是 YES，表示自动回收。
- @property BOOL evictsObjectsWithDiscardedContent;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//返回键值关联对象
- (nullable ObjectType)objectForKey:(KeyType)key;

//在缓存个中设置指定键名对应的值
//与可变字典不同，缓存对象不会对键名做 copy 操作
- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost

//在缓存中设置指定键名对应的值，并且指定该键值对的成本
//成本 (cost) 用于计算记录在缓冲中的所有对象的总成本，成本可以自行指定
- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;

//移除指定键关联的对象
- (void)removeObjectForKey:(KeyType)key;

//移除所有缓存对象
- (void)removeAllObjects;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;代理&quot;&gt;代理&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property(assign) id&amp;lt; NSCacheDelegate &amp;gt; delegate

//缓存将要删除对象时调用
//不能在此方法中修改缓存
- (void)cache:(NSCache *)cache willEvictObject:(id)obj;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;成本的理解&quot;&gt;成本的理解&lt;/h3&gt;

&lt;p&gt;在上述提到的属性和方法中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- @property NSUInteger totalCostLimit;	

- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两个是搭配使用的，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;totalCostLimit&lt;/code&gt;控制最大成本，限制缓存大小。
&lt;code class=&quot;highlighter-rouge&quot;&gt;setObject: forKey: cost:&lt;/code&gt;其中 cost 表示当前对象的大小。&lt;/p&gt;

&lt;p&gt;比如，我们希望用我们的缓存来存储图片，我们限制图片缓存的总成本为 10M。&lt;/p&gt;

&lt;p&gt;那么我们我们可以这么设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_cache.totalCostLimit = 10; //假设我们的单位为 M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们添加图片到缓存中的时候，可以如下添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[_cache setObject:image forKey:key cost:5];//假设我们的图片大小 5M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么我们添加第一、二个图片的时候，就会存入到图片缓存中（假设图片大小都是5M）。现在我们来添加第三张图片，发现我们的缓存已经到了最大值，我们无法添加，
那么 NSCache,就会把第一张图片从缓存中删除，然后来检查是空间是否已经足够添加第三张图片了，如果不够，那么继续删除第二张，如果够了，那么把第三张图片添加到缓存中。&lt;/p&gt;

&lt;p&gt;这是我们假设的一个例子，实际开发中我们并不知道图片的大小。通常，精确的 cost 应该是对象占用的字节数。如果它不可以直接读出来的话，你没必要费劲地去计算它，因为这么做的话会增加使用缓存的代价，导致性能变差。&lt;/p&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你没有有效的值传入，那就传入 0，或者用 setObject:forKey: 方法，它不需要传入 cost 值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;代码示例&quot;&gt;代码示例&lt;/h3&gt;

&lt;p&gt;声明 NSCache 变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property (nonatomic, strong) NSCache *cache;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;懒加载：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSCache *)cache {
    if (_cache == nil) {
        _cache = [[NSCache alloc] init];
        // 设置数量限制,最大限制为3
        _cache.countLimit = 3;
        _cache.delegate = self;
    }
    return _cache;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//添加缓存
-(void)addCache{
    for (int i = 0 ; i &amp;lt; 5 ; i++) {
        NSString *str = [NSString stringWithFormat:@&quot;在这里进行了存储数据：%d&quot;,i];
        [self.cache setObject:str forKey:@(i)];
        NSLog(@&quot;存储数据----%@&quot;,@(i));
    }
}

// 检查缓存
- (void)checkCache {
    NSLog(@&quot;---------------------------------------------&quot;);
    for (int i = 0; i &amp;lt; 5 ; i++) {
        NSString *str = [self.cache objectForKey:@(i)];
        if (str) {
            NSLog(@&quot;取出缓存中存储的数据-----%@&quot;,@(i));
        }
    }
}

#pragma mark - NSCacheDelegate
// 即将回收对象的时候进行调用，实现代理方法之前要遵守NSCacheDelegate协议。
- (void)cache:(NSCache *)cache willEvictObject:(id)obj{
    NSLog(@&quot;回收--------%@&quot;,obj);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行，点击添加缓存按钮：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;存储数据----0
存储数据----1
存储数据----2
回收--------在这里进行了存储数据：0
存储数据----3
回收--------在这里进行了存储数据：1
存储数据----4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们设置 _cache.countLimit = 3，所以在存储第四条数据时，先释放了第一条数据，在添加第四条数据，第五条数据也是如此。&lt;/p&gt;

&lt;p&gt;点击查看缓存按钮验证下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;取出缓存中存储的数据-----2
取出缓存中存储的数据-----3
取出缓存中存储的数据-----4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;缓存中只有三条数据，与我们设置的 countLimi 为 3 一致。&lt;/p&gt;

</description>
        <pubDate>Fri, 24 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/24/iOS-NSCache-%E7%BC%93%E5%AD%98.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/24/iOS-NSCache-%E7%BC%93%E5%AD%98.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 第七章 系统框架</title>
        <description>&lt;h2 id=&quot;第-47-条-熟悉系统框架&quot;&gt;第 47 条 熟悉系统框架&lt;/h2&gt;

&lt;p&gt;我之前这篇文章&lt;a href=&quot;https://www.jianshu.com/p/f1942262542d&quot;&gt;iOS 框架&lt;/a&gt;有介绍过，下面简单介绍下书中内容。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将一系列代码封装为动态库，并在其中放入描述其接口的头文件，这样做出来的东西就叫框架。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 iOS 上的框架为 Cocaa Touch 框架，其实其本身并不是框架，但是里面集成了一批创建应用程序时经常会用到的框架。&lt;/p&gt;

&lt;p&gt;我们开发者碰到的主要框架就是 &lt;a href=&quot;https://www.jianshu.com/p/f1942262542d&quot;&gt;Foundation&lt;/a&gt;和&lt;a href=&quot;https://www.jianshu.com/p/f1942262542d&quot;&gt;UIKit&lt;/a&gt;两大框架。其中 Foundation 框架是 Objective-C 应用程序的“基础”。&lt;/p&gt;

&lt;h2 id=&quot;第-48-条-多用块枚举少用-for-循环&quot;&gt;第 48 条 多用块枚举，少用 for 循环&lt;/h2&gt;

&lt;p&gt;遍历 collection 有四种方式。最基本的方法是for循环，其次是 NSEnumerator 遍历法及快速遍历法，最新最先进的的方式则是“block枚举法”。&lt;/p&gt;

&lt;h3 id=&quot;1for-循环&quot;&gt;1、for 循环&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//遍历数组
NSArray *anArray = /*...*/;
for (int i = 0; i &amp;lt; anArray.count; i++)
{
    id object = anArray[i];
    //Do something with 'object'
}

//遍历字典
NSDictionary *aDictionary = /*...*/;
NSArray *keys = [aDictionary allKeys];
for (int i = 0; i &amp;lt; keys.count; i++)
{
    id key = keys[i];
    id value = aDictionary[key];
    //Do something with 'key' and 'value'
}

//遍历 set
NSSet *aSet = /*...*/;
NSArray *objects = [aSet allObjects];
for (int i = 0; i &amp;lt; objects.count; i++)
{
    id object = objects[i];
    //Do something with 'object'
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在遍历字典或者 Set 时，有点稍复杂，需要先获取字典中所有的键或 Set 中所有的对象，会增加额外的开销。&lt;/p&gt;

&lt;h3 id=&quot;2nsenumerator&quot;&gt;2、NSEnumerator&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//数组
NSArray *anArray = /* ... */;
NSEnumerator *enumerator = [anArray objectEnumerator];
id object;
while ((object = [enumerator nextObject]) != nil)
{
    // Do something with 'object'
}

//字典
NSDictionary *aDictionary = /* ... */;
NSEnumerator *enumerator = [aDictionary keyEnumerator];
id key;
while ((key = [enumerator nextObject]) != nil)
{
    id value = aDictionary[key];
    // Do something with 'key' and 'value'
}

//Set
// Set
NSSet *aSet = /* ... */;
NSEnumerator *enumerator = [aSet objectEnumerator];
id object;
while ((object = [enumerator nextObject]) != nil)
{
    // Do something with 'object'
}

//反向遍历数组
NSArray *anArray = /* ... */;
NSEnumerator *enumerator = [anArray reverseObjectEnumerator];
id object;
while ((object = [enumerator nextObject]) != nil)
{
    // Do something with 'object'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与 for 循环相似，但在遍历数组时无法拿到下标，而我们一般开发时都会需要用到下标。&lt;/p&gt;

&lt;h3 id=&quot;3快速遍历法&quot;&gt;3、快速遍历法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//数组
NSArray *anArray = /* ... */;
for (id object in anArray)
{
    // Do something with 'object'
}

//字典
NSDictionary *aDictionary = /* ... */;
for (id key in aDictionary)
{
    id value = aDictionary[key];
    // Do something with 'key' and 'value'
}

// Set
NSSet *aSet = /* ... */;
for (id object in aSet)
{
    // Do something with 'object'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种办法是简单且效率高的，然而如果在遍历字典时需要同时获取键与值，那么会多出来一步。而且，与传统for循环不同，这种遍历方式无法轻松获取当前遍历操作所针对的下标。遍历时通常会用到这个下标，比如很多算法都需要它。&lt;/p&gt;

&lt;h3 id=&quot;4基于-block-遍历方式&quot;&gt;4、基于 block 遍历方式&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//数组
NSArray *anArray = /* ... */;
[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)
{
    // Do something with 'object'
    if (shouldStop)
    {
        *stop = YES;
    }
}];

//字典
NSDictionary *aDictionary = /* ... */;
[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop)
{
    // Do something with 'key' and 'object'
    if (shouldStop)
    {
        *stop = YES;
     }
}];

//Set
NSSet *aSet = /* ... */;
[aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop)
{
    // Do something with 'object'
    if (shouldStop)
    {
    	*stop = YES;
    }
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遍历时可以直接从block里获取更多信息。在遍历数组时，可以知道当前所针对的下标。遍历有序set（NSOrderedSet）时也一样。而在遍历字典时，无须额外编码，即可同时获取键与值，因而省去了根据给定键来获取对应值这一步。用这种方式遍历字典，可以同事得知键与值，这很可能比其他方式快很多，因为在字典内部的数据结构中，键与值本来就是存储在一起的。&lt;/p&gt;

&lt;h2 id=&quot;第-49-条-对自定义其内存管理语义的-collection-使用无缝桥接&quot;&gt;第 49 条 对自定义其内存管理语义的 collection 使用无缝桥接&lt;/h2&gt;

&lt;p&gt;通过无缝桥接技术，可以在Foundation框架中的OC对象与Core Foundation框架中的C语言数据之间来回转换。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *arr = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;];
CFArrayRef  aCFArray = (__bridge CFArrayRef)arr;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进行转换操作的修饰符共有3个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OC对象 -&amp;gt; CF
__bridge // ARC不交出对象的所有权
__bridge_retained // ARC交出对象的所有权，手动管理内存，需要调用 CFRelease() 进行释放。
 
CF -&amp;gt; OC对象
__bridge_transfer // ARC获得对象的所有权，自动管理内存
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;第-50-条-构建缓存时选用-nscache-而非-nsdictionary&quot;&gt;第 50 条 构建缓存时选用 NSCache 而非 NSDictionary&lt;/h2&gt;

&lt;p&gt;NSCache胜过NSDictionary的之处在于：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当系统资源将要耗尽时，它可以自动删减缓存。&lt;/li&gt;
  &lt;li&gt;NSCache还会先行删减“最久未使用的”(lease recently used)对象。&lt;/li&gt;
  &lt;li&gt;NSCache 并不会“拷贝”键，而是会“保留”它。NSCache对象不拷贝键的原因在于：很多时候，键都是有不支持拷贝操作的对象来充当的。因此，NSCache 不会自动拷贝键，所以说，在健不支持拷贝操作的情况下，该类用起来比字典更方便。&lt;/li&gt;
  &lt;li&gt;NSCache是线程安全的。而NSDictionary则绝不具备此优势，意思就是：在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问NSCache.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-51-条-精简-initialize-与-load-的实现代码&quot;&gt;第 51 条 精简 initialize 与 load 的实现代码&lt;/h2&gt;

&lt;h3 id=&quot;voidload&quot;&gt;+(void)load&lt;/h3&gt;

&lt;p&gt;1、对于加入运行期系统的类及分类，必定会调用此方法，且仅调用一次。&lt;/p&gt;

&lt;p&gt;2、iOS会在应用程序启动的时候调用load方法，在main函数之前调用。&lt;/p&gt;

&lt;p&gt;3、执行子类的load方法前，会先执行所有超类的load方法，顺序为父类-&amp;gt;子类-&amp;gt;分类，则先调用类里面的，再调用分类里面的。&lt;/p&gt;

&lt;p&gt;4、在load方法中使用其他类是不安全的，因为会调用其他类的load方法，而如果关系复杂的话，就无法判断出各个类的载入顺序，类只有初始化完成后，类实例才能进行正常使用。&lt;/p&gt;

&lt;p&gt;5、load 方法不遵从继承规则，如果类本身没有实现load方法，那么系统就不会调用，不管父类有没有实现（跟下文的initialize有明显区别）。&lt;/p&gt;

&lt;p&gt;6、尽可能的精简load方法，因为整个应用程序在执行load方法时会阻塞，即，程序会阻塞直到所有类的load方法执行完毕，才会继续。&lt;/p&gt;

&lt;p&gt;7.、oad 方法中最常用的就是方法交换method swizzling。&lt;/p&gt;

&lt;h3 id=&quot;voidinitialize&quot;&gt;+(void)initialize&lt;/h3&gt;

&lt;p&gt;1、对于每个类来说,在首次使用该类之前，且仅调用一次.它是由运行期系统来调用的，绝不应该通过代码直接调用。&lt;/p&gt;

&lt;p&gt;2、惰性调用，只有当程序使用相关类(该类或子类)时，才会调用,因此，如果某个类一直都没有使用，那么initialize方法就一直不会运行。&lt;/p&gt;

&lt;p&gt;3、运行期系统会确保initialize方法是在线程安全的环境中执行，即，只有执行initialize的那个线程可以操作类或类实例。其他线程都要先阻塞，等待initialize执行完。&lt;/p&gt;

&lt;p&gt;4、如果类未实现initialize方法，而其超类实现了，那么会运行超类的实现代码，而且会运行两次。&lt;/p&gt;

&lt;p&gt;5、initialize方法也需要尽量精简，只应该用来设置内部数据：
比如，某个全局状态无法在编译期初始化，可以放在initialize里面。&lt;/p&gt;

&lt;p&gt;6、对于分类中的initialize方法，会覆盖该类的initialize方法。&lt;/p&gt;

&lt;h2 id=&quot;第-52-条-别忘了-nstime-会保留其目标对象&quot;&gt;第 52 条 别忘了 NSTime 会保留其目标对象&lt;/h2&gt;

&lt;p&gt;NSTimer 对象会保留其目标，若要释放其目标需要计时器本身失效，失效有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们手动调用 invalidate 方法可伶计时器失效；&lt;/li&gt;
  &lt;li&gt;一次性的计时器在触发完任务之后也会失效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用计时器反复执行任务时，通常会造成循环引用。如果我们对代码逻辑非常清楚，则手动调用 invalidate 方法就可以了，但还有更好的方法使我们我无须关注目标对象释放问题。&lt;/p&gt;

&lt;p&gt;我们通常的写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface EOCClass : NSObject
- (void)startPolling;
- (void)stopPolling;
@end
 
@implementation EOCClass{
    NSTimer *_poliTimer;
}
 
- (id) init{
    return [super init];
}
 
- (void)dealloc{
    [_poliTimer invalidate];
}
 
- (void)stopPolling{
    [_poliTimer invalidate];
    _poliTimer = nil;
}
 
- (void)startPolling{
    _poliTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES];
}
 
- (void)p_doPoll{
    // code

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用stopPolling方法或令系统将实例回收（会自动调用dealloc方法）可以使计时器失效，从而打破循环，但无法确保startPolling方法一定调用，而由于计时器保存着实例，实例永远不会被系统回收。当EOCClass实例的最后一个外部引用移走之后，实例仍然存活，而计时器对象也就不可能被系统回收，除了计时器外没有别的引用再指向这个实例，实例就永远丢失了，造成内存泄漏。&lt;/p&gt;

&lt;p&gt;优化后的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface NSTimer (EOCBlocksSupport)
+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;
@end
 
@implementation NSTimer( EOCBlocksSupport)
 
+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void (^)())block repeats:(BOOL)repeats{
    return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats];
}
 
+ (void)eoc_blockInvoke:(NSTimer*)timer{
    void (^block)() = timer.userInfo;
    if (block) {
        block();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再修改 startPolling 方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)startPolling{
    __weak EOCClass *weakSelf = self;
    _poliTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{
        EOCClass *strongSelf = weakSelf;
        [strongSelf p_doPoll];
    } repeats:YES];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码先定义了一个弱引用指向self，然后用块捕获这个引用，这样self就不会被计时器所保留，当块开始执行时，立刻生成strong引用，保证实例在执行器继续存活。&lt;/p&gt;

&lt;p&gt;采用这种写法之后，如果外界指向 EOCClass 实例的最后一个引用将其释放，则该实例就可为系统所回收了。回收过程中还会调用计时器的 invalidate 方法，这样的话，计时器就不会再执行任务了。此处使用 weak 引用还能令程序更加安全，因为有时开发者可能在编写 dealloc 时忘了调用计时器的 invalidate 方法，从而导致计时器再次运行，若发生此类情况，则块里的 weakSelf 会变成 nil。&lt;/p&gt;

&lt;h3 id=&quot;要点&quot;&gt;要点：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NSTimer 对象会保留其目标，直到计时器本身失效为止，调用 invalidate 方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反复执行任务的计时器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以扩充 NSTimer 的功能，用 “块”来打破保留环。不过，除非 NSTimer 将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 23 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/23/Effective-Objective-C-2.0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/23/Effective-Objective-C-2.0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6.html</guid>
        
        <category>iOS</category>
        
        <category>Effective Objective-C 2.0</category>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 第六章 块与大中枢派发(二)</title>
        <description>&lt;h2 id=&quot;第-41-条-多用派发队列少用同步锁&quot;&gt;第 41 条 多用派发队列，少用同步锁&lt;/h2&gt;

&lt;p&gt;多个线程执行同一份代码的情况下，我们需要加锁，有以下三种方法：&lt;/p&gt;

&lt;h3 id=&quot;1使用同步块&quot;&gt;1、使用同步块&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)synchronizedMethod
{
    @synchronized (self) {
    //Safe
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;滥用@synchronized (self)则会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。若是在self对象上频繁加锁，那么程序可能要等另一段与此无关的代码执行完毕，才能继续执行当前代码，这样做其实并没有必要。&lt;/p&gt;

&lt;p&gt;在极端情况下，同步块会导致死锁，另外，其效率也不见得很高，而如果直接使用锁对象的话，一旦遇到死锁，就会非常麻烦。&lt;/p&gt;

&lt;h3 id=&quot;2使用-nslock-对象&quot;&gt;2、使用 NSLock 对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_lock = [[NSLock alloc]init];

- (void)synchronizedMethod{
	[_lock lock];
 	//Safe
	[_lock unlock];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这么做虽然能提供某种程度的“线程安全”（thread safety），但却无法保证访问该对象时绝对是线程安全的，当然访问属性的操作确实是“原子的”。在两次访问操作之间，其他线程可能会写入新的属性值，造成了在同一个线程上多次调用获取方法（getter），每次获取到的结果未必相同。&lt;/p&gt;

&lt;h3 id=&quot;3使用-gcd&quot;&gt;3、使用 GCD&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_syncqueue = dispatch_queue_create(&quot;com.test.concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);

- (NSString *)something{
    __block NSString *localSomething = nil;
    dispatch_sync(_syncqueue, ^{
        localSomething = _something;
    });
    return localSomething;
}

- (void)setSomething:(NSString *)something{
    dispatch_barrier_async(_syncqueue, ^{
        _something = something;
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看图理解下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1776587-72d708b61d18dcea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个并发队列中，读取操作使用普通的块来实现，而写入操作则是用栅栏块来实现的。读取操作可以并行，但写入操作必须单独执行，因为他是栅栏块。&lt;/p&gt;

&lt;h3 id=&quot;要点&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用@synchronized块或NSLock对象更简单。&lt;/li&gt;
  &lt;li&gt;将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。&lt;/li&gt;
  &lt;li&gt;使用同步队列及栅栏块，可令同步行为更加高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-42-条-多用-gcd少用-performselector-系列方法&quot;&gt;第 42 条 多用 GCD，少用 performSelector 系列方法&lt;/h2&gt;

&lt;p&gt;NSObject定义了几个方法，令开发者可以随意调用任何方法。这几个方法可以推迟执行方法调用，也可以指定运行方法所用的线程。这些功能原来很有用，但是在出现了大中枢派发及块这样的新技术之后，就显得不那么必要了。虽说有些代码还是会经常用到它们，但笔者劝你还是避开为妙。&lt;/p&gt;

&lt;p&gt;这其中最简单的是&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector：&lt;/code&gt;。该方法与直接调用选择子等效。所以下面两行代码的执行效果相同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self performSelector:@selector(selectorName)];
[self selectorName];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;performSelector还有如下几个版本，可以再发消息时顺便传递参数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector&lt;/code&gt;方法太过局限，最多支持两个函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SEL selector;
if (/* some condition */) {
    selector = @selector(foo);
}else if (/* some other condition */){
    selector = @selector(bar);
}else{
    selector = @selector(baz);
}
[object performSelector:selector];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样写编译器汇报内存泄漏警告。原因在于，编译器并不知道将要调用的选择子是什么，因此也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用ARC的内存管理规则来判定返回值是不是应该释放，鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时 可能已经将其保留了。&lt;/p&gt;

&lt;h3 id=&quot;替代方案&quot;&gt;替代方案&lt;/h3&gt;

&lt;p&gt;最主要的替代方案就是使用块（参见第37条）。而且，performSelector系列方法所提供的线程功能，都可以通过在大中枢派发机制中使用块来实现。延后执行可以用dispatch_after来实现，在另一个线程上执行任务则可通过dispatch_sync及dispatch_async来实现。&lt;/p&gt;

&lt;p&gt;例如延后执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));

dispatch_after(time, dispatch_get_main_queue(), ^{
    [self doSomething];
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;想把任务放在主线程上执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_async(dispatch_get_main_queue(), ^{
    [self doSomething];
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;要点-1&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector&lt;/code&gt;系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector&lt;/code&gt;系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。&lt;/li&gt;
  &lt;li&gt;如果想把任务放在另一个线程上执行，那么最好不要用&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector&lt;/code&gt;系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-43-条-掌握-gcd-及操作队列的使用时机&quot;&gt;第 43 条 掌握 GCD 及操作队列的使用时机&lt;/h2&gt;

&lt;p&gt;GCD技术确实很棒，不过有时候采用标准系统库的组件，效果会更好。一定要了解每项技巧的使用时机。&lt;/p&gt;

&lt;p&gt;很少有其它技术能与GCD的同步机制（参见第41条）相媲美。对于那些只需执行一次的代码来说，也是如此，使用GCD的dispatch_once（参见第45条）最为方便。然而，在执行后台任务时，GCD并不一定是最佳方式。还有一种技术叫做NSOperationQueue，它虽然与GCD不同，但却与之类似，开发者可以把操作以NSOperation子类的形式放在队列中，而这些操作也能够并发执行。其与GCD派发队列有相似之处，这并非巧合。“操作队列”（operation queue）在GCD之前就有了，其中有些设计原理因操作队列而流行，GCD就是基于这些原理构建的。实际上，从iOS4与MAC OSX 10.6开始，操作队列在底层是用GCD来实现的。&lt;/p&gt;

&lt;p&gt;在两者的诸多差别中，首先要注意：GCD是纯C的API，而操作队列则是Objective-C的对象。在GCD中，任务用块来表示，而块是个轻量级数据结构（参见第37条）。与之相反，“操作”（operation）则是个更为重量级的Objective—C对象。&lt;/p&gt;

&lt;p&gt;用NSOperationQueue类的“addOperationWithBlock:”方法搭配NSBlockOperation类来使用操作队列其语法与纯GCD方式非常类似。是用NSOperation及NSOperationQueue的好处如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;取消某个操作。如果使用操作队列，那么想要取消操作队列是很容易的。运行任务之前，可以在NSOperation对象上调用cancel方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。若是不使用操作队列，而是把块安排到GCD队列，那就无法取消了。开发者可以在应用程序层自己来实现取消功能，不过这样做需要编写很多代码，而那些代码其实已经由操作队列实现好了。&lt;/li&gt;
  &lt;li&gt;指定操作间的依赖关系。一个操作可以依赖其他多个操作。开发者能够制定操作之间的依赖体系，使特定的操作必须在另外一个操作顺利执行完毕后方可执行。&lt;/li&gt;
  &lt;li&gt;通过键值观测机制监控NSOperation对象的属性。NSOperation对象有许多属性都适合通过键值观测机制（简称KVO）来监听。比如可以通过isCancelled属性来判断任务是否已取消，又比如可以通过isFinished属性来判断任务是否已完成。&lt;/li&gt;
  &lt;li&gt;指定操作的优先级。操作的优先级表示此操作与队列中其他操作之间的优先级关系。优先级高的操作先执行，优先级低的后执行。操作队列的调度算法（scheduling algorithm）虽“不透明”（opaque），但必然是经过一番深思熟虑才写成的。反之，GCD则没有直接实现此功能的办法。GCD的队列确实有优先级，不过那是针对整个队列来说的，而不是针对每个块来说的。NSOperation对象也有“线程优先级”（thread priority），这决定了运行此操作的线程处在何种优先级上。用GCD也可实现此功能，然而采用操作队列更简单，只需设置一个属性。&lt;/li&gt;
  &lt;li&gt;重用NSOperation对象。系统内置了一些NSOperation的子类（比如NSBlockOperation）以供开发者调用，要是不想用这些固有子类的话，那就得自己来创建了。这些类就是普通的Objective-C对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。这就比派发队列中那些简单的块要强大许多。这些NSOperation类可以在代码中多次使用，他们符合软件开发中的“不重复”（Do’t Repeat Yourself，DRY）原则。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有一个API选用了操作队列而非派发队列，这就是NSNotificationCenter，这个方法接受的参数是块，而不是选择子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id &amp;lt;NSObject&amp;gt;)addObserverForName:(nullable NSString *)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block NS_AVAILABLE(10_6, 4_0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本来这个方法也可以不使用操作队列，而是把处理通知事件所用的块安排在派发队列里。但实际上并没有这样做，其设计者显然使用了高层的Objective-C API。在这种情况下，两套方案的运行效率没多大差距。设计这个方法的人可能不想使用派发队列，因为那样做将依赖于GCD，而这种依赖没有必要，前面说过，块本身和GCD无关。&lt;/p&gt;

&lt;p&gt;经常会有人说：应该尽可能选用高层API，只在确有必要时才求助与底层。笔者也同意这个说法，但我并不盲从。某些功能确实可以用高层的Objective-C方法来做，但这并不等于说它就一定比底层实现方案好。要想确定哪种方案更佳，最好还是测试一下性能。&lt;/p&gt;

&lt;h2 id=&quot;第-44-条-通过-dispatch-group-机制根据系统资源状况来执行任务&quot;&gt;第 44 条 通过 Dispatch Group 机制，根据系统资源状况来执行任务&lt;/h2&gt;

&lt;p&gt;dispatch group是GCD的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。这个功能有许多用途，其中最重要、最值得注意的用法，就是把将要并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。&lt;/p&gt;

&lt;h3 id=&quot;创建-group&quot;&gt;创建 group:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_group_t group = dispatch_group_create();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;给任务编组&quot;&gt;给任务编组&lt;/h3&gt;

&lt;p&gt;两种方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//第一种方法：
void dispatch_group_async(dispatch_group_t group,
                          dispatch_queue_t queue,
                          dispatch_block_t block);

//第二种方法
dispatch_group_enter(dispatch_group_t group)
dispatch_group_leave(dispatch_group_t group)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第二种方法中，调用了dispatch_group_enter以后，必须又与之对应的dispatch_group_leave才行。这与引用计数（参见第29条）相似，要使用引用计数。就必须令保留操作与释放操作彼此对应，以防内存泄漏。&lt;/p&gt;

&lt;h3 id=&quot;任务组执行完毕&quot;&gt;任务组执行完毕&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此函数接受两个参数，一个是要等待的group，另一个是代表等待时间的timeout值。timeout参数表示函数在等待dispatch group执行完毕时，应该阻塞多久。如果执行dispatch group所需的时间小于timeout，则返回0，否则返回非0值。此参数也可以取常量DISPATCH_TIME_FOREVER，这表示函数会一直等待dispatch group执行完，而不会超时（time out）。&lt;/p&gt;

&lt;p&gt;也可以使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatch_group_notify(dispatch_group_t group,
                           dispatch_queue_t queue,
                           dispatch_block_t block);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与wait函数略有不同的是：开发者可以向此函数传入块，等dispatch group执行完毕之后，块会在特定的线程上执行。加入当前此案成不应阻塞，而开发者又想在那些任务全部完成时得到通知，那么此做法就很有必要了。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_group_t dispatchGroup = dispatch_group_create();

NSArray * collection;
for (id object in collection) {
    dispatch_group_async(dispatchGroup, queue, ^{
        [object description];
    });
}

//第一种，有超时
dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);
//Continue processing after completing tasks

//或者使用第二种，没有超时
dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^{
    //Continue processing after completing tasks
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;要点-2&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。&lt;/li&gt;
  &lt;li&gt;通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时，GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-45-条-使用-dispatch_once-来执行只需运行一次的线程安全代码&quot;&gt;第 45 条 使用 dispatch_once 来执行只需运行一次的线程安全代码&lt;/h2&gt;

&lt;p&gt;原来创建单例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@implementation EOCClass

+ (instancetype)sharedInstance
{
    static EOCClass *sharedInstance = nil;
    @synchronized (self) {
        if (!sharedInstance) {
            sharedInstance = [[self alloc] init];
        }
    }
    return sharedInstance;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;笔者发现单例模式容易引起激烈争论，Objective-C的单例尤其如此。线程安全是大家争论的主要问题。为保证线程安全，上述代码将创建单例实例的代码包裹在同步块里。&lt;/p&gt;

&lt;p&gt;使用 dispatch_once 创建单例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (instancetype)sharedInstance
{
    static EOCClass *sharedInstance = nil;
    static dispatch_once_t onceToken;

    dispatch_once(&amp;amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });

    return sharedInstance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用dispatch_once可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或同步。所有问题都有GCD在底层处理。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。把该变量定义在static作用域中，可以保证编译器在每次执行shareInstance方法时都会复用这个变量，而不会创建新变量。&lt;/p&gt;

&lt;p&gt;此外，dispatch_once更高效。他没有使用重量级的同步机制，若是那样的话，每次运行代码前都要获取锁，相反，此函数采用“原子访问”（atomic access）来查询标记，以判断其所对应的代码原来是否已经执行过。&lt;/p&gt;

&lt;h3 id=&quot;要点-3&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过GCD所提供的dispatch_once函数，很容易就能实现此功能。&lt;/li&gt;
  &lt;li&gt;标记应该声明在static或global作用域中，这样的话，在把只需执行一次的块传给dispatch_once函数时，穿进去的标记也是相同的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-46-条-不要使用-dispatch_get_current_queue&quot;&gt;第 46 条 不要使用 dispatch_get_current_queue&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_get_current_queue(void);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此函数在 iOS 6.0 版本以后，已经废弃。&lt;/p&gt;

</description>
        <pubDate>Wed, 22 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/22/Effective-Objective-C-2.0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9D%97%E4%B8%8E%E5%A4%A7%E4%B8%AD%E6%9E%A2%E6%B4%BE%E5%8F%91(%E4%BA%8C).html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/22/Effective-Objective-C-2.0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9D%97%E4%B8%8E%E5%A4%A7%E4%B8%AD%E6%9E%A2%E6%B4%BE%E5%8F%91(%E4%BA%8C).html</guid>
        
        <category>iOS</category>
        
        <category>Effective Objective-C 2.0</category>
        
        
      </item>
    
      <item>
        <title>NSlog 输出格式</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; %@           OC对象

 %d,%i        整型 (%i的老写法)
 
 %hd          短整型
 
 %ld,%lld     长整型
 
 %u           无符整型
 
 %f           浮点型和double型
 
 %0.2f        精度浮点数，只保留两位小数
 
 %x:       为32位的无符号整型数(unsigned int),打印使用数字0-9的十六进制,小写a-f;
 
 %X:       为32位的无符号整型数(unsigned int),打印使用数字0-9的十六进制,大写A-F;
 
 %o            八进制
 
 %zu/%zd       size_t/NSInteger
 
 %p            指针地址
 
 %e            float/double（科学计数）
 
 %g            float/double（科学计数）
 
 %s            char *  字符串
 
 %.*s          Pascal字符串
 
 %c            char 字符
 
 %C            unichar
 
 %Lf           64位double
 
 %lu           sizeof(i)内存中所占字节数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;几种不同的打印函数&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLog(&amp;lt;#NSString * _Nonnull format, ...#&amp;gt;)     --&amp;gt; OC
printf(&amp;lt;#const char *restrict, ...#&amp;gt;)          --&amp;gt; C
CFShow(&amp;lt;#CFTypeRef obj#&amp;gt;)                      --&amp;gt; Core Foundation
CFShowStr(&amp;lt;#CFStringRef str#&amp;gt;)                 --&amp;gt; Core Foundation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLog(@&quot;当前方法名：%@&quot;,NSStringFromSelector(_cmd));
NSLog(@&quot;当前方法名: %s&quot;,sel_getName(_cmd));
NSLog(@&quot;[类 方法]：%s&quot;,__func__);
NSLog(@&quot;[类 方法]：%s&quot;,__FUNCTION__);
NSLog(@&quot;当前类名：%@&quot;,NSStringFromClass([self class]));
NSLog(@&quot;当前行号：%d&quot;,__LINE__);
NSLog(@&quot;当前文件存储路径：%s&quot;,__FILE__);
NSString *pathStr = [NSString stringWithCString:__FILE__ encoding:NSUTF8StringEncoding]; //将CString -&amp;gt; NSString
NSLog(@&quot;当前文件名：%@&quot;,[pathStr lastPathComponent]);

NSLog(@&quot;当前日期：%s&quot;,__DATE__);
NSLog(@&quot;当前时间：%s&quot;,__TIME__);
NSLog(@&quot;当前App运行要求的最低ios版本：%d&quot;,__IPHONE_OS_VERSION_MIN_REQUIRED);  //Develop Target: 已选8.0
NSLog(@&quot;当前App支持的最高ios版本：%d&quot;,__IPHONE_OS_VERSION_MAX_ALLOWED);    //Develop Target: 最高9.0
NSLog(@&quot;打印__IPHONE_7_0：%d&quot;,__IPHONE_7_0);  //打印ios7.0
    
NSLog(@&quot;当前线程：%@&quot;,[NSThread currentThread]);
NSLog(@&quot;主线程：%@&quot;,[NSThread mainThread]);
NSLog(@&quot;当前栈信息：%@&quot;, [NSThread callStackSymbols]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/stevenwuzheng/p/5485986.html&quot;&gt;https://www.cnblogs.com/stevenwuzheng/p/5485986.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 18 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/18/NSlog-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/18/NSlog-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 第六章 块与大中枢派发(一)</title>
        <description>&lt;h2 id=&quot;第-37-条-理解块这一概念&quot;&gt;第 37 条 理解“块”这一概念&lt;/h2&gt;

&lt;p&gt;Block：带有自动变量的匿名函数。&lt;/p&gt;

&lt;p&gt;匿名函数：没有函数名的函数，一对 {} 包裹的内容是匿名函数的作用域。&lt;/p&gt;

&lt;p&gt;自动变量：栈上声明的一个变量不是静态变量和全局变量，是不可以在这个栈内声明的匿名函数中使用的，但在 Block 中却可以。&lt;/p&gt;

&lt;p&gt;虽然使用 Block 不用声明类，但是 Block 提供了 Objective-C 的类一样可以通过成员变量来保存作用域外变量值的方法，那些在 Block 的一对 {} 里使用到但却是在 {} 作用域以外声明的变量，就是 Block 截获的自动变量。&lt;/p&gt;

&lt;h3 id=&quot;block表达式语法&quot;&gt;Block表达式语法：&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;^ 返回值类型 (参数列表) {表达式}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;^ int (int count){
    return count + 1;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中可以省略返回类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;^(int count){
	return count + 1;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;若参数为空，则可以写为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;^{
	return count + 1;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即最简模式语法为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;^ {表达式}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;block类型变量&quot;&gt;Block类型变量&lt;/h3&gt;

&lt;p&gt;声明Block类型变量语法:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;返回值类型 (^变量名)(参数列表) = Block表达式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如，如下声明了一个变量名为blk的Block：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int (^blk)(int) = ^(int count) {
    return count + 1;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当Block类型变量作为函数的参数时，写作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)func:(int (^)(int))blk {
    NSLog(@&quot;Param:%@&quot;, blk);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;借助 typedef 可简写:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (^blk_k)(int);

- (void)func:(blk_k)blk {
    NSLog(@&quot;Param:%@&quot;, blk);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Block 类型变量作返回值时，写作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (int (^)(int))funcR {
    return ^(int count) {
        return count ++;
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;借助 typedef 简写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (^blk_k)(int);

- (blk_k)funcR {
    return ^(int count) {
        return count ++;
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;block与外界变量&quot;&gt;Block与外界变量&lt;/h3&gt;

&lt;h4 id=&quot;截获自动变量值&quot;&gt;截获自动变量值&lt;/h4&gt;

&lt;p&gt;对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的。也就是说 block 的自动变量截获只针对 block 内部使用的自动变量, 不使用则不截获, 因为截获的自动变量会存储于 block 的结构体内部, 会导致 block 体积变大。特别要注意的是默认情况下 block 只能访问不能修改局部变量的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1776587-82740df0ecff6ff8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; int i = 10;
 void (^blk)(void) = ^{
     NSLog(@&quot;In block, i = %d&quot;, i);
 };
 i = 20;//Block外修改变量i，也不影响Block内的自动变量
 blk();//i修改为20后才执行，打印: In block, i = 10
 NSLog(@&quot;i = %d&quot;, i);//打印：i = 20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;__block-修饰的外部变量&quot;&gt;__block 修饰的外部变量&lt;/h4&gt;

&lt;p&gt;对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的。block 可以修改 __block 修饰的外部变量的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1776587-257e7df0f58fe62a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block int i = 10;//i为__block变量，可在block中重新赋值
void (^blk)(void) = ^{
    NSLog(@&quot;In block, i = %d&quot;, i);
};
i = 20;
blk();//打印: In block, i = 20
NSLog(@&quot;i = %d&quot;, i);//打印：i = 20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自动变量值为一个对象情况&quot;&gt;自动变量值为一个对象情况&lt;/h3&gt;

&lt;p&gt;当自动变量为一个类的对象，且没有使用__block修饰时，虽然不可以在Block内对该变量进行重新赋值，但可以修改该对象的属性。&lt;/p&gt;

&lt;p&gt;如果该对象是个Mutable的对象，例如NSMutableArray，则还可以在Block内对NSMutableArray进行元素的增删：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *array = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;,nil ];
NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:2
void (^blk)(void) = ^{
    [array removeObjectAtIndex:0];//Ok
    //array = [NSNSMutableArray new];//没有__block修饰，编译失败！
};
blk();
NSLog(@&quot;Array Count:%ld&quot;, array.count);//打印Array Count:1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;block-存储域&quot;&gt;Block 存储域&lt;/h3&gt;

&lt;p&gt;block 有三种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全局块(_NSConcreteGlobalBlock)&lt;/li&gt;
  &lt;li&gt;栈块(_NSConcreteStackBlock)&lt;/li&gt;
  &lt;li&gt;堆块(_NSConcreteMallocBlock)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;全局块存在于全局内存中, 相当于单例；
栈块存在于栈内存中, 超出其作用域则马上被销毁；
堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存；&lt;/p&gt;

&lt;p&gt;遇到一个Block，我们怎么这个Block的存储位置呢？&lt;/p&gt;

&lt;p&gt;(1) Block 不访问外界变量（包括栈中和堆中的变量）&lt;/p&gt;

&lt;p&gt;Block 既不在栈又不在堆中，在代码段中，ARC和MRC下都是如此。此时为全局块。&lt;/p&gt;

&lt;p&gt;(2) Block 访问外界变量&lt;/p&gt;

&lt;p&gt;MRC 环境下：访问外界变量的 Block 默认存储栈中。
ARC 环境下：访问外界变量的 Block 默认存储在堆中（实际是放在栈区，然后ARC情况下自动又拷贝到堆区），自动释放。&lt;/p&gt;

&lt;h2 id=&quot;第-38-条-为常用的块类型创建-typedef&quot;&gt;第 38 条 为常用的块类型创建 typedef&lt;/h2&gt;

&lt;p&gt;上文已经提到过，见下面代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (^blk_k)(int);

- (void)func:(blk_k)blk {
    NSLog(@&quot;Param:%@&quot;, blk);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;第-39-条-用-handler-块降低代码分散程度&quot;&gt;第 39 条 用 handler 块降低代码分散程度&lt;/h2&gt;

&lt;p&gt;异步方法在执行完任务之后，需要以某种手段通知相关代码。实现此功能有很多办法。常用的技巧是设计一个委托协议（参见第23条），令关注此事的对象遵从该协议。对象成为delegate之后，就可以在相关事件发生时（例如某个异步任务执行完毕时）得到通知了。
如果改用块来写的话，代码会更清晰。块可以令这种API变得更紧致，同时也令开发者调用起来更加方便。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef void (^EOCNetworkFetcherCompletionHandler)(NSData *data);

@interface EOCNetworkFetcher : NSObject
- (id)initWithURL:(NSURL *)url;
- (void)startWithCompletionHandler: (EOCNetworkFetcherCompletionHandler)handler;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSURL *url = [[NSURL alloc] initWithString:@&quot;http:www.baidu.com&quot;];
EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
[fetcher startWithCompletionHandler:^(NSData *data) {
    _fetchedFooData = data;
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;第-40-条-用块引用其所属对象时不要出现保留环&quot;&gt;第 40 条 用块引用其所属对象时不要出现保留环&lt;/h2&gt;

&lt;p&gt;Block 循环引用的情况：
某个类将 block 作为自己的属性变量，然后该类在 block 的方法体里面又使用了该类本身，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.someBlock = ^(Type var){
    [self dosomething];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;解决方法：
对Block内要使用的对象 A 使用&lt;strong&gt;_weak&lt;/strong&gt;进行修饰，Block 对对象 A 弱引用打破循环。&lt;/p&gt;

&lt;p&gt;1、使用__weak ClassName&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__weak XXViewController* weakSelf = self;
self.blk = ^{
    NSLog(@&quot;In Block : %@&quot;,weakSelf);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、 使用__weak typeof(self)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__weak typeof(self) weakSelf = self;
self.blk = ^{
    NSLog(@&quot;In Block : %@&quot;,weakSelf);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3、 对 Block 内要使用的对象 A 使用 __block 进行修饰，并在代码块内，使用完 __block 变量后将其设为 nil，并且该 block 必须至少执行一次。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block XXController *blkSelf = self;
self.blk = ^{
    NSLog(@&quot;In Block : %@&quot;,blkSelf);
    blkSelf = nil;//不能省略
};
    
self.blk();//该block必须执行一次，否则还是内存泄露
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4、 将在 Block 内要使用到的对象（一般为 self 对象），以 Block 参数的形式传入，Bloc k就不会捕获该对象，而将其作为参数使用，其生命周期系统的栈自动管理，不造成内存泄露。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.blk = ^(UIViewController *vc) {
    NSLog(@&quot;Use Property:%@&quot;, vc.name);
};
self.blk(self);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们常用的还是前两条，使用 __weak 修饰。&lt;/p&gt;

</description>
        <pubDate>Thu, 16 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/16/Effective-Objective-C-2.0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9D%97%E4%B8%8E%E5%A4%A7%E4%B8%AD%E6%9E%A2%E6%B4%BE%E5%8F%91(%E4%B8%80).html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/16/Effective-Objective-C-2.0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9D%97%E4%B8%8E%E5%A4%A7%E4%B8%AD%E6%9E%A2%E6%B4%BE%E5%8F%91(%E4%B8%80).html</guid>
        
        <category>iOS</category>
        
        <category>Effective Objective-C 2.0</category>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 第五章 内存管理</title>
        <description>&lt;h2 id=&quot;第-29-条-理解引用计数&quot;&gt;第 29 条 理解引用计数&lt;/h2&gt;

&lt;h3 id=&quot;引用计数原理&quot;&gt;引用计数原理&lt;/h3&gt;

&lt;p&gt;引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1.若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。&lt;/p&gt;

&lt;p&gt;在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。&lt;/p&gt;

&lt;h3 id=&quot;属性存取方法中的内存管理&quot;&gt;属性存取方法中的内存管理&lt;/h3&gt;

&lt;p&gt;若属性 foo 由 strong 修饰，则其 set 方法会保留新值，释放旧值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setFoo:(id)foo {
    [foo retain];
    [_foo release];
    _foo = foo;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自动释放池&quot;&gt;自动释放池&lt;/h3&gt;

&lt;p&gt;autorelease 能延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。&lt;/p&gt;

&lt;p&gt;自动释放池中的释放操作是在当前线程的下一次事件循环。&lt;/p&gt;

&lt;h3 id=&quot;保留环&quot;&gt;保留环&lt;/h3&gt;

&lt;p&gt;循环引用。&lt;/p&gt;

&lt;p&gt;在垃圾收集环境中，通常将这种情况认定为”孤岛”(island of isolation)。此时，垃圾收集器会把三个对象全都回收走。而在Objective-C的引用计数架构中，则享受不到这一便利。通常采用”弱引用”(weak reference， 参见第33条)来解决此问题，或是从外界命令循环中的某个对象不再保留另外一个对象。这两种办法都能打破保留环，从而避免内存泄漏。&lt;/p&gt;

&lt;h2 id=&quot;第-30-条-以-arc-简化引用计数&quot;&gt;第 30 条 以 ARC 简化引用计数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;有 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC  来编程，可省去类中的许多 “样板代码”。&lt;/li&gt;
  &lt;li&gt;ARC 管理对象生命期的办法基本上就是：在合适的地方插入 “保留” 及 “释放”操作。&lt;/li&gt;
  &lt;li&gt;在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来需要手工执行 “保留” 及 “释放”操作。&lt;/li&gt;
  &lt;li&gt;由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC 将此确定为开发者必须遵守的规则。&lt;/li&gt;
  &lt;li&gt;ARC 只负责管理 Objective-C  对象的内存。尤其要注意： CoreFoundation 对象不归 ARC  管理，开发者必须适时调用 CFRetain/CFRelease。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-31-条-在-dealloc-方法中只释放引用并解除监听&quot;&gt;第 31 条 在 dealloc 方法中只释放引用并解除监听&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观测”（KVO）或NSNotificationCenter等通知，不要做其他事情。&lt;/li&gt;
  &lt;li&gt;如果对象持有文件描述符等系统资源，那么应该专门写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法。&lt;/li&gt;
  &lt;li&gt;执行异步任务的方法不应该在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-32-条-编写异常安全代码时留意内存管理问题&quot;&gt;第 32 条 编写“异常安全代码”时留意内存管理问题&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;捕获异常时，一定要注意将try块内所创立的对象清理干净。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在默认情况下，ARC不生成安全处理一次所需的清理代码。开启编译器标志后（-fobjc-arc-exceptions）,可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-33-条-以弱引用避免保留环&quot;&gt;第 33 条 以弱引用避免保留环&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;将某些引用设为weak，可避免出现“保留环”。&lt;/li&gt;
  &lt;li&gt;weak引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着ARC而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过得对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-34-条-以自动释放池块降低内存峰值&quot;&gt;第 34 条 以“自动释放池块”降低内存峰值&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;自动释放池排布在栈中,对象收到 autorelease 后,系统将其放入最顶端的池里。&lt;/li&gt;
  &lt;li&gt;合理运用自动释放池,能够降低应用程序的内存峰值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-35-条-用僵尸对象调试内存管理问题&quot;&gt;第 35 条 用“僵尸对象”调试内存管理问题&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombieEnabled 可开启此功能。&lt;/li&gt;
  &lt;li&gt;系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使改对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-36-条-不要使用-retaincount&quot;&gt;第 36 条 不要使用 retainCount&lt;/h2&gt;

&lt;p&gt;在 MRC 下可以使用此方法查询对象的保留技术，ARC 环境下已经废弃此方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对象的保留计数看似有用，实则不然，因为任何给定时间点上的 ‘绝对保留计数’ 都无法反映对象生命期的全貌。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;引入 ARC 之后,retainCount 方法就正式废止了。在 ARC 下调用该方法会导致编译器报错。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 15 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/15/Effective-Objective-C-2.0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/15/Effective-Objective-C-2.0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html</guid>
        
        <category>iOS</category>
        
        <category>Effective Objective-C 2.0</category>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 第四章 协议与分类</title>
        <description>&lt;h2 id=&quot;第-23-条-通过委托与数据源协议进行对象间通信&quot;&gt;第 23 条 通过委托与数据源协议进行对象间通信&lt;/h2&gt;

&lt;p&gt;1、Objective-C 可以使用 “委托模式”（Delegate pattern）的编程设计模式来实现对象间的通信：定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其 “委托对象”（delegate）。Objective-C 一般利用 “协议” 机制来实现此模式。&lt;/p&gt;

&lt;p&gt;2、定义协议：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@protocol EOCNetworkingFetcherDelegate
@optional
- (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher
            didRecevieData:(NSData *)data;
- (void)newworkingFetcher:(EOCNetworkingFetcher *)fetcher
         didFailWithError:(NSError *)error;
@end
@interface EOCNetworkingFetcher : NSObject
@property (nonatomic,weak) id delegate;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;委托协议名通常时在相关的类名加上Delegate 一词，也是采用 “驼峰法” 来命名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类可以用一个属性存放其委托对象，属性要用weak 来修饰，避免产生 “保留环”（retain cycle）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某类若要遵从某委托协议，可以在其接口中声明，也可以在”class-continuation 分类” 中声明，如果要向外界公布此类实现了某协议，就在接口中声明，如果这个协议是个委托协议，通常只会在这个类的内部使用，这样子就在分类中声明就好了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、如果要在委托对象上调用可选方法，那么必须提前使用类型信息查询方法，判断这个委托对象能否响应相关的选择子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSData *data;
if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)]){
    [_delegate networkFetcher:self didRecevieData:data];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4、delegate 里的方法也可以用于从委托对象中获取信息（数据源模式）。&lt;/p&gt;

&lt;p&gt;5、在实现委托模式和数据源模式的时，协议中的方法是可选的，我们就会写出大量这种判断代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if([_delegate respondsToSelector:@selector(networkFetcher:didRecevieData:)]){
    [_delegate networkFetcher:self didRecevieData:data];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每次调用方法都会判断一次，其实除了第一次检测的结构有用，后续的检测很有可能都是多余的，因为委托对象本身没变，不太可能会一下子不响应，一下子响应的，所以我们这里可以把这个委托对象能否响应某个协议方法记录下来，以优化程序效率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将方法响应能力缓存起来的最佳途径是使用 “位段”（bitfield）数据类型。我们可以把结构体中某个字段所占用的二进制位个数设为特定的值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;位段，C语言允许在一个结构体中以位为单位来指定其成员所占内存长度，这种以位为单位的成员称为“位段”或称“位域”( bit field) 。&lt;/p&gt;

  &lt;p&gt;struct data {&lt;/p&gt;

  &lt;p&gt;unsigned int filedA : 8;&lt;/p&gt;

  &lt;p&gt;unsigned int filedB : 4;&lt;/p&gt;

  &lt;p&gt;unsigned int filedC : 2;&lt;/p&gt;

  &lt;p&gt;unsigned int filedD : 1;&lt;/p&gt;

  &lt;p&gt;}&lt;/p&gt;

  &lt;p&gt;filedA 位段占用8个二进制位，filedB 位段占用4个二进制位，filedC 位段占用2个二进制位，filedD位段占用1个二进制位。filedA 就可以表示0至255之间的值，而filedD 则可以表示0或1这两个值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们可以像filedD 这样子，创建大小只有1的位段，这样子就可以把Boolean 值塞入这一小块数据里面，这里很适合这样子做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以网络数据获取器为例，可以在该实例中嵌入一个含有位段的结构体作为其实例变量，而结构体中的每个位段则表示 delegate 对象是否实现了协议中的相关方法。此结构体的用法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface EOCNetworkFetcher () {
    struct {
        unsigned int didReceiveData : 1;
        unsigned int didFailWithError : 1;
        unsigned int didUpdateProgressTo : 1;
    } _delegateFlags;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个结构体用来缓存委托对象是否能响应特定的选择子。实现缓存功能所用的代码可以写在 delegate 属性所对应的设置方法里:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setDelegate:(id&amp;lt;EOCNetworkFetcherDelegate&amp;gt;)delegate {
    _delegate = delegate;
    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];
    _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(netWorkFetcher:didFailWithError:)];
    _delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector(networkFetcher:didUpdateProgressTo:)];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样的话，每次调用 delegate 的相关方法之前，就不用检测委托对象是否能响应给定的选择子了，而是直接查询结构体里的标志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (_delegateFlags.didUpdateProgressTo) {
	[_delegate networkFetcher:self didUpdateProgressTo:currentProgress];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在相关方法要调用很多次时，值得进行这种优化。而是否需要优化，则应依照具体代码来定。这就需要分析代码性能，并找出瓶颈，若发现执行速度需要改进，则可使用此技巧。如果要频繁通过数据源协议从数据源中获取多份相互独立的数据，那么这项优化技术极有可能会提高程序效率。&lt;/p&gt;

&lt;h3 id=&quot;要点&quot;&gt;要点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象&lt;/li&gt;
  &lt;li&gt;将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。&lt;/li&gt;
  &lt;li&gt;当某个对象需要从另一个对象中获取数据时，可以使用委托模式。这种情景下，该模式亦成为“数据源协议”（data source protocal）。&lt;/li&gt;
  &lt;li&gt;如果有必要，可以实现含有位段的结构体，将委托对象是否能相应相关协议方法这一信息缓存其中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-24-条-将类的实现代码分散到便于管理的数个分类中&quot;&gt;第 24 条 将类的实现代码分散到便于管理的数个分类中&lt;/h2&gt;

&lt;p&gt;一个类经常有很多方法，尽管代码写的比较规范，这个文件还是会越来越大，定位问题以及阅读上都会造成不便。我们可以通过 “分类” 机制来把代码按逻辑划分到几个分区中。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface TestObject : NSObject&amp;lt;NSCopying,NSMutableCopying&amp;gt;

@property(nonatomic,copy)NSString *name;

-(instancetype)initWithName:(NSString *)name;

//work methods
-(void)performDaysWork;
-(void)takeVacationFromWork;

//play methods
-(void)goToTheCinema;
-(void)goToSportsGame;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;利用分类，改写成这样：&lt;/p&gt;

&lt;p&gt;TestObject.h:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface TestObject : NSObject
@property(nonatomic,copy)NSString *name;
-(instancetype)initWithName:(NSString *)name;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TestObject (work).h&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;TestObject.h&quot;
@interface TestObject (work)
-(void)performDaysWork;
-(void)takeVacationFromWork;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TestObject (Play).h&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;TestObject.h&quot;
@interface TestObject (Play)
-(void)goToTheCinema;
-(void)goToSportsGame;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;要点-1&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用分类机制把类的实现代码划分成易于管理的小块。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将应该视为 “私有” 的方法归入为叫Private 的分类中，以隐藏实现细节。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-25-条-总是为第三方类的分类名称加前缀&quot;&gt;第 25 条 总是为第三方类的分类名称加前缀&lt;/h2&gt;

&lt;p&gt;向第三方类中添加分类时，总应该给其名称加上你专用的前缀。&lt;/p&gt;

&lt;p&gt;向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。&lt;/p&gt;

&lt;h2 id=&quot;第-26-条勿在分类中声明属性&quot;&gt;第 26 条：勿在分类中声明属性&lt;/h2&gt;

&lt;p&gt;可以利用运行期的关联对象机制，为分类声明属性，但是这种做法要尽量避免，因为除了 “class-continuation 分类” 之外，其他分类都无法向类中新增实例变量，因此，他们无法把实现属性所需的实例变量合成出来。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;尽量把封装数据所用的全部属性都定义在主接口里。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 “class-continuation 分类” 之外的其他分类中，可以定义存取方法，但尽量不要定义属性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-27-条使用-class-continuation-分类-隐藏实现细节&quot;&gt;第 27 条：使用 ”class-continuation 分类“ 隐藏实现细节&lt;/h2&gt;

&lt;p&gt;就是在 .m 文件中声明属性和方法，隐藏实现细节：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;TestObject.h&quot;

@interface TestObject ()

@property(nonatomic,copy)NSString *privateStr;

-(void)privateMethod;

@end

@implementation TestObject


@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;通过 “class-continuation 分类” 向类中新增实例变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果某属性在主接口中声明为 “只读”，而类的内部又要用设置方法修改此属性，那么就在 “class-continuation 分类” 中将其扩展为 “可读写”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把私有方法的原型声明在 “class-contiunation 分类” 里面。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若想使类所遵循的协议不为人所知，则可于 “class-contiunation 分类” 中声明。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-28-条通过协议提供匿名对象&quot;&gt;第 28 条：通过协议提供匿名对象&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property(nonatomic,weak)id&amp;lt;EOCDelegate&amp;gt;delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该属性是 id&lt;EOCDelegate&gt;，所以任何类的对象都可以充当这一属性，只要遵循 EOCDelegate 协议就行。&lt;/EOCDelegate&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id 类型，协议里规定了对象所应实现的方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用匿名对象来隐藏类型名称（或类名）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 14 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/14/Effective-Objective-C-2.0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E7%B1%BB.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/14/Effective-Objective-C-2.0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E7%B1%BB.html</guid>
        
        <category>iOS</category>
        
        <category>Effective Objective-C 2.0</category>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 第三章 接口与 API 设计</title>
        <description>&lt;h2 id=&quot;第-15-条用前缀避免命名空间冲突&quot;&gt;第 15 条：用前缀避免命名空间冲突&lt;/h2&gt;

&lt;p&gt;1、选择与你的公司、应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中使用这一前缀。&lt;/p&gt;

&lt;p&gt;Apple 宣称其保留使用所有“两字母前缀”的权利，所以我们使用前缀时候最好是三个字母的。举个例子，假如开发者不遵守这条守则，使用 TW 这两个字母作为前缀，那么就会出现问题。iOS 5.0 SDK 发布时，包含 Twitter 框架，此框架就使用 TW 作前缀，其中有个类叫做 TWRequest，它可以发送 HTTP 请求以调用 Twitter API。如果你所在的公司叫做 Tiny Widgets，那么很有那可能把访问本公司 API 所用的那个类也命名为 TWRequest。&lt;/p&gt;

&lt;p&gt;2、若自己所开发的程序中用到了第三方库，并准备将其发布为程序库供他人开发应用，则应为其中的名称加上前缀。&lt;/p&gt;

&lt;h2 id=&quot;第-16-条提供全能初始化方法&quot;&gt;第 16 条：提供“全能初始化方法”&lt;/h2&gt;

&lt;p&gt;“designated initializer” 直译为 “指定初始化方法”，本书译为”全能初始化方法”。&lt;/p&gt;

&lt;p&gt;就是提供必要信息的初始化方法。如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法，我们需要选定一个作为全能初始化方法，令其它初始化方法都来调用他。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface YXRectangle : NSObject
@property (nonatomic,readonly) float width;
@property (nonatomic,readonly) float height;
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
@end
@implementation YXRectangle

- (instancetype)init{
    return [self initWithWidth:500 height:600];
}

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height{
    self = [super init];
    if (self) {
        _width = width;
        _height = height;
    }
    return self;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-(instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height&lt;/code&gt;这个方法就是全能初始化方法。这个类的所有初始化方法最终都会通过全能初始化方法创建。&lt;/p&gt;

&lt;h3 id=&quot;子类的初始化方式&quot;&gt;子类的初始化方式：&lt;/h3&gt;

&lt;p&gt;比如我们创建一个正方形的子类 YXSquare&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface YXSquare : YXRectangle
- (instancetype)initWithDimension:(CGFloat)dimension;
@end
@implementation YXSquare

- (instancetype)initWithDimension:(CGFloat)dimension{
   return  [super initWithWidth:dimension height:dimension];
}

//要阻止子类直接调用父类的全能初始化方式，这样有可能出现长宽不等的情况。
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height{
    @throw  [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must be use initWithDimension :instead&quot; userInfo:nil];
}

//如果不重写的话，使用者可能会使用 init 创建实例，这样会调用父类的 init 方法，可能会出现长宽不等的情况，所以需要重写。
-(instancetype)init{
    return [self initWithDimension:500];
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;存在两个全能初始化方法&quot;&gt;存在两个全能初始化方法&lt;/h3&gt;

&lt;p&gt;对象实例有两种完全不同的创建方式，必须分开处理，就会出现这种情况。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)initWithCoder:(NSCoder *)decoder;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们在实现此方法时一般不调用平常所使用的那个全能初始化方法，因为该方法要通过”解码器”(decoder)将对象数据解压缩，所以和普通的初始化方法不同。因此，严格的说，在这种情况下出现了两个全能初始化方法。&lt;/p&gt;

&lt;p&gt;具体到父类 YXRectangle 代码就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface YXRectangle : NSObject
@property (nonatomic,readonly) float width;
@property (nonatomic,readonly) float height;
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
@end
@implementation YXRectangle

- (instancetype)init{
    return [self initWithWidth:500 height:600];
}

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height{
    self = [super init];
    if (self) {
        _width = width;
        _height = height;
    }
    return self;
}

-(id)initWithCoder:(NSCoder *)decoder{
	if(self = [super init]){
		_width = [decoder decodeFloatForKey:@&quot;width&quot;];
		_height = [decoder decodeFloatForKey:@&quot;height&quot;];
	}
	return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子类 YXSquare：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface YXSquare : YXRectangle
- (instancetype)initWithDimension:(CGFloat)dimension;
@end
@implementation YXSquare

- (instancetype)initWithDimension:(CGFloat)dimension{
   return  [super initWithWidth:dimension height:dimension];
}

//要阻止子类直接调用父类的全能初始化方式，这样有可能出现长宽不等的情况。
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height{
    @throw  [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must be use initWithDimension :instead&quot; userInfo:nil];
}

//如果不重写的话，使用者可能会使用 init 创建实例，这样会调用父类的 init 方法，可能会出现长宽不等的情况，所以需要重写。
-(instancetype)init{
    return [self initWithDimension:500];
}

-(id)initWithCoder:(NSCoder *)decoder{
	if((self = [super initWithCoder:decoder])){
		//YXSquare's specific initializer
	}
	return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上，实现&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithCoder:&lt;/code&gt;时也要这样，应该先调用超类的相关方法，然后再执行与本类有关的任务。这样编写出来的 YXSquare 类就完全遵守 NSCoding 协议了(fully NSCoding compliant)。如果编写&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithCoder:&lt;/code&gt;方法时没有调用超类的同名方法，而是调用了自制的初始化方法，或是超类的其他初始化方法，那么 YXSquare 类的&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithCoder:&lt;/code&gt;方法就没机会执行，于是，也就无法将 _width 及 _height 这两个实例变量解码了。&lt;/p&gt;

&lt;h3 id=&quot;要点&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。&lt;/li&gt;
  &lt;li&gt;若全能初始化方法与超类不同，则需覆写超类中的对应方法。&lt;/li&gt;
  &lt;li&gt;如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-17-条-实现-description-方法&quot;&gt;第 17 条 实现 description 方法&lt;/h2&gt;

&lt;p&gt;我们自定义一个类 TestObject：&lt;/p&gt;

&lt;p&gt;TestObject.h&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface TestObject : NSObject

@property(nonatomic,copy)NSString *name;

-(instancetype)initWithName:(NSString *)name;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TestObject.m&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;TestObject.h&quot;

@implementation TestObject

-(instancetype)initWithName:(NSString *)name{
    if (self = [super init]) {
        _name = [name copy];
    }
    return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们打印查看对象信息时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TestObject *obj = [[TestObject alloc]initWithName:@&quot;Bob&quot;];
NSLog(@&quot;obj = %@&quot;,obj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obj = &amp;lt;TestObject: 0x283880010&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们只能看到类名和对象地址，得不到我们想要的信息。这时候想要看到更详细的信息，需要重写&lt;code class=&quot;highlighter-rouge&quot;&gt;-(NSString *)description&lt;/code&gt;方法。在 TestObject.m 中，改为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;TestObject.h&quot;

@implementation TestObject

-(instancetype)initWithName:(NSString *)name{
    if (self = [super init]) {
        _name = [name copy];
    }
    return self;
}

-(NSString *)description{
    return [NSString stringWithFormat:@&quot;&amp;lt;%@: %p, %@&amp;gt;&quot;,
            [self class],
            self,
            @{@&quot;name&quot;:_name}];
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时再次运行，控制台输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obj = &amp;lt;TestObject: 0x2818ec610, {
    name = Bob;
}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样在打印自定义类时，就能得到我们想要的信息。&lt;/p&gt;

&lt;p&gt;还有与&lt;code class=&quot;highlighter-rouge&quot;&gt;-(NSString *)description&lt;/code&gt;方法功能相同的另一个方法&lt;code class=&quot;highlighter-rouge&quot;&gt;-(NSString *)debugDescription&lt;/code&gt;,两者的区别就是后者是开发者在调试器中以控制台命令打印对象才调用的。在 NSObject 类默认实现中，debugDescription 直接调用了 description。我们可以重写 debugDescription 方法，以便在调试时打印出更详尽的信息。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(NSString *)description{
    return [NSString stringWithFormat:@&quot;&amp;lt;%@&amp;gt;&quot;,
            @{@&quot;name&quot;:_name}];
}

-(NSString *)debugDescription{
    return [NSString stringWithFormat:@&quot;&amp;lt;%@: %p, %@&amp;gt;&quot;,
            [self class],
            self,
            @{@&quot;name&quot;:_name}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 description 中，我们不需要看到类名与指针地址，而在调试时候想要看到更详尽的，就可以这么写。&lt;/p&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    
    TestObject *obj = [[TestObject alloc]initWithName:@&quot;Bob&quot;];
    NSLog(@&quot;obj = %@&quot;,obj);
    //此处打一个断点
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打印：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;obj = &amp;lt;{
    name = Bob;
}&amp;gt;
(lldb) po obj //此处使用 LLDB 的 “po” 命令可以完成对象打印
&amp;lt;TestObject: 0x2816ec010, {
    name = Bob;
}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;要点-1&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;实现 description 方法返回一个有意义的字符串，用以描述该实例。&lt;/li&gt;
  &lt;li&gt;若想在调试时打印出更详尽的对象描述信息，则应实现 debugDescription 方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-18-条-尽量使用不可变对象&quot;&gt;第 18 条 尽量使用不可变对象&lt;/h2&gt;

&lt;p&gt;就是声明属性为 readonly。这样可以防止外人改动。&lt;/p&gt;

&lt;p&gt;有时我们需要修改封装在对象内部的数据，可以在类扩展中将对象重新声明为 readwrite。例如：&lt;/p&gt;

&lt;p&gt;EOCPointOfInterest.h:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
 
@interface EOCPointOfInterest : NSObject
 
@property (nonatomic, copy, readonly) NSString *identifier;
 
@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;EOCPointOfInterest.m&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;EOCPointOfInterest.h&quot;
 
@interface EOCPointOfInterest()
 
@property (nonatomic, copy, readwrite) NSString *identifier;
 
@end
 
@implementation EOCPointOfInterest
 
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对象表示的各种集合属性，应该提供一个readonly属性供外界使用，该属性将返回不可变的集合，而该集合是内部那个可变集合的一份拷贝。即不要把可变的集合作为属性公开，而应该提供相关方法，以此修改对象中的可变集合。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 头文件：
#import &amp;lt;Foundation/Foundation.h&amp;gt;
 
@interface EOCPerson : NSObject
 
@property (nonatomic, copy, readonly) NSString *firstName;
@property (nonatomic, copy, readonly) NSString *lastName;
@property (nonatomic, copy, readonly) NSSet *friends;
 
- (id)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName;
- (void)addFriend:(EOCPerson *)person;
- (void)removeFriend:(EOCPerson *)person;
 
@end
 
// 实现文件：
#import &quot;EOCPerson.h&quot;
 
@interface EOCPerson()
 
@property (nonatomic, copy, readwrite) NSString *firstName;
@property (nonatomic, copy, readwrite) NSString *lastName;
 
@end
 
@implementation EOCPerson {
    NSMutableSet *_internalFriends;
}
 
- (NSSet *)friends
{
    return [_internalFriends copy];
}
 
 - (void)addFriend:(EOCPerson *)person
{
    [_internalFriends addObject:person];
}
 
- (void)removeFriend:(EOCPerson *)person
{
    [_internalFriends removeObject:person];
}
 
- (id)initWithFirstName:(NSString *)firstName andLastName:(NSString *)lastName
{
    if (self = [super init]) {
        _firstName = firstName;
        _lastName = lastName;
        _internalFriends = [NSMutableSet new];
    }
    return self;
}
 
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;要点-2&quot;&gt;要点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;尽量创建不可变的对象&lt;/li&gt;
  &lt;li&gt;若某属性仅可于对象内部修改，则在 “class-continuation 分类”中将其由 readonly 属性扩展为 readwrite 属性。&lt;/li&gt;
  &lt;li&gt;不要把可变的 collection 作为属性公开，而应提供相关方法，以此修改对象中可变的 collection。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-19-条使用清晰而协调的命名方式&quot;&gt;第 19 条：使用清晰而协调的命名方式&lt;/h2&gt;

&lt;p&gt;有种代码即文档的感觉，读起来就像日常用语的句子。不要用缩略后的名称来命名，例如用 str 替代 string。&lt;/p&gt;

&lt;p&gt;给方法命名时可以总结成下面几条规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果方法的返回值时新创建的，那么方法名的首个词应是返回值的类型。例如&lt;code class=&quot;highlighter-rouge&quot;&gt;+stringWithString&lt;/code&gt;。除非前面还有个修饰词例如&lt;code class=&quot;highlighter-rouge&quot;&gt;localizedString&lt;/code&gt;,用来描述其逻辑含义。&lt;/li&gt;
  &lt;li&gt;应该吧表示参数类型的名词放在参数前面。例如&lt;code class=&quot;highlighter-rouge&quot;&gt;-(instancetype)initWithName:(NSString *)name&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;如果方法要在当前对象上执行操作，那么就应该包含动词；&lt;/li&gt;
  &lt;li&gt;不要使用 str 这种简称，应该使用 string 这样的全称。&lt;/li&gt;
  &lt;li&gt;Bool 属性应加 is/has 前缀。&lt;/li&gt;
  &lt;li&gt;将get 这个前缀留给那些借由“输出参数”来保存返回值的方法。比如，把返回值填充到“C语言式数组”（C-style array）里的那种方法就可以使用这个词做前缀。例：NSString类里的&lt;code class=&quot;highlighter-rouge&quot;&gt;-(void)getCharacters:(unichar*)buffer range:(NSRange)aRange&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-20-条为私有方法名加前缀&quot;&gt;第 20 条：为私有方法名加前缀&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;给私有方法的名称加上前缀，这样可以很容易地将其同公共方法分开。&lt;/li&gt;
  &lt;li&gt;不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-21-条-理解-objective-c-错误模型&quot;&gt;第 21 条 理解 Objective-C 错误模型&lt;/h2&gt;

&lt;h3 id=&quot;1极其严重的错误使用异常&quot;&gt;1、极其严重的错误使用异常&lt;/h3&gt;

&lt;p&gt;例如某人使用了我们自己编写的某个抽象基类，可以考虑抛出异常。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)mustOverrideMethod {
    @throw [NSException 
        exceptionWithName:NSInternalInconsistencyException
        reason:[NSString stringWithFormat:@&quot;%@ must be overridden&quot;, _cmd]
        userInfo:nil];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2一般错误可以令方法返回-nil-或使用-nserror&quot;&gt;2、一般错误可以令方法返回 nil 或使用 NSError&lt;/h3&gt;

&lt;h4 id=&quot;使用-nil&quot;&gt;使用 nil&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)initWithValue:(id)value {
    if ((self = [super init])) {
        if ( /* Value means instance can’t be created */ ) {
            self = nil;
        } else {
            // Initialise instance
        }
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这种情况下，如果 if 语句发现无法用传入的参数值来初始化当前实例（比如这个方法要求传入的 value 参数必须是 non-nil 的），那么就把 self 设置成 nil，这样的话，整个方法的返回值也就是 nil 了。调用者发现初始化方法并没有把实例创建好，于是便可确定其中发生了错误。&lt;/p&gt;

&lt;h4 id=&quot;使用-nserror&quot;&gt;使用 NSError&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)doSomethingError:(NSError**)error {
    // Do something that may cause an error
    
    if (/* there was an error */) {
        if (error) {
            *error = [NSError errorWithDomain:NSURLErrorDomain
                                         code:110
                                     userInfo:nil];
        }
        return NO;///&amp;lt; Indicate failure
    } else {
        return YES; ///&amp;lt; Indicate success
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用这段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSError *error = nil;
BOOL ret = [object doSomethingError:&amp;amp;error];
if (!ret) {
    // There was an error
    NSLog(@&quot;err = %@&quot;,error);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以获取到错误信息。&lt;/p&gt;

&lt;h3 id=&quot;要点-3&quot;&gt;要点：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;只有发生了可使整个应用程序崩溃的严重错误时，才使用异常。&lt;/li&gt;
  &lt;li&gt;在错误不那么严重的情况下，可以指派“委托方法”来处理错误，也可以把错误信息放在 NSError 对象里，经由“输出参数”返回给调用者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第-22-条-理解-nscopying-协议&quot;&gt;第 22 条 理解 NSCopying 协议&lt;/h2&gt;

&lt;p&gt;NSCopying 协议下只有这一个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)copyWithZone:(nullable NSZone *)zone;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中参数 zone 已经不再使用，我们无需关心。&lt;/p&gt;

&lt;p&gt;当我们自定义对象想要具有拷贝功能时，我们就需要实现此协议。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;TestObject.h&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface TestObject : NSObject&amp;lt;NSCopying&amp;gt;

@property(nonatomic,copy)NSString *name;

-(instancetype)initWithName:(NSString *)name;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TestObject.m&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;TestObject.h&quot;

@implementation TestObject

-(instancetype)initWithName:(NSString *)name{
    if (self = [super init]) {
        _name = name;
    }
    return self;
}

-(id)copyWithZone:(NSZone *)zone{
    
    TestObject *obj = [[[self class]allocWithZone:zone]initWithName:_name];
    return obj;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然了，这样实现的是浅拷贝。我们若想实现深拷贝，需要实现 NSMutableCopying 协议，其协议下也只有一个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)mutableCopyWithZone:(nullable NSZone *)zone;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中参数 zone 没有用，不用考虑。返回一个可变对象就可以了。&lt;/p&gt;

&lt;h3 id=&quot;要点-4&quot;&gt;要点：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。&lt;/li&gt;
  &lt;li&gt;如果自定义的对象分为可变版本和不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。&lt;/li&gt;
  &lt;li&gt;复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。&lt;/li&gt;
  &lt;li&gt;如果你写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 13 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/13/Effective-Objective-C-2.0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E4%B8%8E-API-%E8%AE%BE%E8%AE%A1.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/13/Effective-Objective-C-2.0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E4%B8%8E-API-%E8%AE%BE%E8%AE%A1.html</guid>
        
        <category>iOS</category>
        
        <category>Effective Objective-C 2.0</category>
        
        
      </item>
    
      <item>
        <title>iOS * 与 &amp; 以及二级指针</title>
        <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;： 星号，用来声明指针的；&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;：连字号运算符，定义内存位置；&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;二级指针&lt;/code&gt;：指向指针的指针。&lt;/p&gt;

&lt;h2 id=&quot;指针&quot;&gt;指针&lt;/h2&gt;

&lt;p&gt;指针是一个变量，它的值是另一个变量的地址。&lt;/p&gt;

&lt;p&gt;我们先声明一个变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int var = 20;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再声明一个指针：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int *p = &amp;amp;var; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 p 是指针变量名称，它的值指向的是 var 的地址。&lt;/p&gt;

&lt;p&gt;我们打印输出一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int var = 20;

int *p = &amp;amp;var;

NSLog(@&quot;%d,%d&quot;,var,*p);

NSLog(@&quot;%p,%p&quot;,&amp;amp;var,p);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;20,20
0x16fc37ecc,0x16fc37ecc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;p-与-p&quot;&gt;*p 与 p&lt;/h3&gt;

&lt;p&gt;从上面例子可以看到，如果我们不理解指针的含义的话，表面上看 *p 应该和 &amp;amp;var 相等才对啊，可实际上是 p 和 &amp;amp;var 相等，*p 和 var 相等。我们再看下指针定义：指针是一个变量，它的值是另一个变量的地址，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 星号是用来声明指针的。所以 上面例子中 p 是指针，p 的值为 var 的地址即 &amp;amp;var。&lt;/p&gt;

&lt;p&gt;那 *p 又是什么？&lt;/p&gt;

&lt;p&gt;*p 就等于 p 中存储的地址（&amp;amp;var）所对应存储单元中的数据 20。&lt;/p&gt;

&lt;p&gt;来张图理解下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1776587-f2f71914f07373ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中每个变量和指针也有自己的地址，变量 var 和指针 p 的地址为 0x16fc37ecc 和 0x16fc37ec0。&lt;/p&gt;

&lt;h2 id=&quot;二级指针&quot;&gt;二级指针&lt;/h2&gt;

&lt;p&gt;二级指针就是指向指针的指针，它的值就是指向指针的地址。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int var = 20;
int *p = &amp;amp;var;
int **p2 = &amp;amp;p;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 p2 就是二级指针，可见其中有两个&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;。同理三级指针就有三个&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;,四级指针就有四个&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;，依次类推。&lt;/p&gt;

&lt;p&gt;他们之间的关系可用下图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1776587-1c57859049e5797f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此图很容易得出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p2 的值为 0x16fc37ec0;

*p2 的值为 0x16fc37ecc;

**p2 的值为 20；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 10 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/10/iOS-%E4%B8%8E-&-%E4%BB%A5%E5%8F%8A%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/10/iOS-%E4%B8%8E-&-%E4%BB%A5%E5%8F%8A%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Effective Objective-C 2.0 第二章 14 理解“类对象”的用意</title>
        <description>&lt;p&gt;我之前这篇文章&lt;a href=&quot;https://www.jianshu.com/p/1f9d37b68aba&quot;&gt;iOS runtime 类与对象&lt;/a&gt;已经详细介绍过类与对象，本篇重点介绍书中内容。&lt;/p&gt;

&lt;p&gt;Objective-C实际上是一门极其动态的语言。第11条讲解了运行期系统如何查找并调用某方法的实现代码，第12条则讲述了消息转发的原理：如果类无法立即响应某个选择子，那么就会启动消息转发流程。然而，消息的接收者究竟是何物？是对象本身吗？运行期系统如何知道某个对象的类型呢？对象类型并非在编译期就绑定好了，而是要在运行期查找。而且，还有个特殊的类型叫做id，它能指代任意的Objective-C对象类型。一般情况下，应该指明消息接收者的具体类型，这样的话，如果向其发送了无法解读的消息，那么编译器就会产生警告信息。而类型为id的对象则不然，编译器假定它能响应所有消息。&lt;/p&gt;

&lt;p&gt;如果看过第12条，你就会明白，编译器无法确定某类型对象到底能解读多少种选择子，因为运行期还可向其中动态新增。然而，即便使用了动态新增技术，编译器也觉得应该能在某个头文件中找到方法原型的定义，据此可了解完整的“方法签名”（method signature），并生成派发消息所需的正确代码。&lt;/p&gt;

&lt;p&gt;“在运行期检视对象类型”这一操作也叫做“类型信息查询”（introspection，“内省”），这个强大而有用的特性内置于Foundation框架的NSObject协议里，凡是由公共根类（common root class，即NSObject与NSProxy）继承而来的对象都要遵从此协议。在程序中不要直接比较对象所属的类，明智的做法是调用“类型信息查询方法”，其原因笔者稍后解释。不过在介绍类型信息查询技术之前，我们先讲一些基础知识，看看Objective-C对象的本质是什么。&lt;/p&gt;

&lt;p&gt;每个Objective-C对象实例都是指向某块内存数据的指针。所以在声明变量时，类型后面要跟一个“*”字符：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *pointerVariable = @&quot;Some string&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编过C语言程序的人都知道这是什么意思。对于没写过C语言的程序员来说，pointerVariable可以理解成存放内存地址的变量，而NSString自身的数据就存于那个地址中。因此可以说，该变量“指向”（point to）NSString实例。所有Objective-C对象都是如此，若是想把对象所需的内存分配在栈上，编译器则会报错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String stackVariable = @&quot;Some string&quot;;  
// error: interface type cannot be statically allocated 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于通用的对象类型id，由于其本身已经是指针了（id 定义：&lt;code class=&quot;highlighter-rouge&quot;&gt;typedef struct objc_object *id;&lt;/code&gt;），所以我们能够这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id genericTypedString = @&quot;Some string&quot;; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这种定义方式与用NSString*来定义相比，其语法意义相同。唯一区别在于，如果声明时指定了具体类型，那么在该类实例上调用其所没有的方法时，编译器会探知此情况，并发出警告信息。&lt;/p&gt;

&lt;p&gt;描述Objective-C对象所用的数据结构定义在运行期程序库的头文件里，id类型本身也在定义在这里：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct objc_object *id;

struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由此可见，每个对象结构体的首个成员是Class类的变量。该变量定义了对象所属的类，通常称为“is a”指针。例如，刚才的例子中所用的对象“是一个”（is a）NSString，所以其“is a”指针就指向NSString。Class对象也定义在运行期程序库的头文件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct objc_class *Class;  
struct objc_class {  
    Class isa;  
    Class super_class;  
    const char *name;  
    long version;  
    long info;  
    long instance_size;  
    struct objc_ivar_list *ivars;  
    struct objc_method_list **methodLists;  
    struct objc_cache *cache;  
    struct objc_protocol_list *protocols;  
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此结构体存放类的“元数据”（metadata），例如类的实例实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是isa指针，这说明Class本身亦为Objective-C对象。结构体里还有个变量叫做super_class，它定义了本类的超类。类对象所属的类型（也就是isa指针所指向的类型）是另外一个类，叫做“元类”（metaclass），用来表述类对象本身所具备的元数据。“类方法”就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。&lt;/p&gt;

&lt;p&gt;假设有个名为SomeClass的子类从NSObject中继承而来，则其继承体系如图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1776587-5cfe05658371feff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;super_class指针确立了继承关系，而isa指针描述了实例所属的类。通过这张布局关系图即可执行“类型信息查询”。我们可以查出对象是否能响应某个选择子，是否遵从某项协议，并且能看出此对象位于“类继承体系”（class hierarchy）的哪一部分。&lt;/p&gt;

&lt;p&gt;在类继承体系中查询类型信息&lt;/p&gt;

&lt;p&gt;可以用类型信息查询方法来检视类继承体系。“isMemberOfClass:”能够判断出对象是否为某个特定类的实例，而“isKindOfClass:”则能够判断出对象是否为某类或其派生类的实例。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary new];  
[dict isMemberOfClass:[NSDictionary class]]; ///&amp;lt; NO 
[dict isMemberOfClass:[NSMutableDictionary class]]; ///&amp;lt; YES 
[dict isKindOfClass:[NSDictionary class]]; ///&amp;lt; YES 
[dict isKindOfClass:[NSArray class]]; ///&amp;lt; NO 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;像这样的类型信息查询方法使用isa指针获取对象所属的类，然后通过super_class指针在继承体系中游走。由于对象是动态的，所以此特性显得极为重要。Objective-C与你可能熟悉的其他语言不同，在此语言中，必须查询类型信息，方能完全了解对象的真实类型。&lt;/p&gt;

&lt;p&gt;由于Objective-C使用“动态类型系统”（dynamic typing），所以用于查询对象所属类的类型信息查询功能非常有用。从collection中获取对象时，通常会查询类型信息，这些对象不是“强类型的”（strongly typed），把它们从collection中取出来时，其类型通常是id。如果想知道具体类型，那就可以使用类型信息查询方法。例如，想根据数组中存储的对象生成以逗号分隔的字符串（comma-separated string），并将其存至文本文件，就可以使用下列代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString*)commaSeparatedStringFromObjects:(NSArray*)array {  
    NSMutableString *string = [NSMutableStringnew];  
    for (id object in array) {  
        if ([object isKindOfClass:[NSStringclass]]) {  
            [string appendFormat:@&quot;%@,&quot;, object];  
        } else if ([object isKindOfClass:[NSNumberclass]]) {  
            [string appendFormat:@&quot;%d,&quot;, [object intValue]];  
        } else if ([object isKindOfClass:[NSDataclass]]) {  
            NSString *base64Encoded = /* base64 encoded data */;  
            [string appendFormat:@&quot;%@,&quot;, base64Encoded];  
        } else {  
            // Type not supported  
        }  
    }  
    return string;  
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以用比较类对象是否等同的办法来做。若是如此，那就要使用==操作符，而不要使用比较Objective-C对象时常用的“isEqual:”方法（参见第8条）。原因在于，类对象是“单例”（singleton），在应用程序范围内，每个类的Class仅有一个实例。也就是说，另外一种可以精确判断出对象是否为某类实例的办法是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id object = /* ... */;  
if ([object class] == [EOCSomeClassclass]) {  
    // 'object' is an instance of EOCSomeClass  
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即便能这样做，我们也应该尽量使用类型信息查询方法，而不应该直接比较两个类对象是否等同，因为前者可以正确处理那些使用了消息传递机制（参见第12条）的对象。比方说，某个对象可能会把其收到的所有选择子都转发给另外一个对象。这样的对象叫做“代理”（proxy），此种对象均以NSProxy为根类。&lt;/p&gt;

&lt;p&gt;通常情况下，如果在此种代理对象上调用class方法，那么返回的是代理对象本身（此类是NSProxy的子类），而非接受的代理的对象所属的类。然而，若是改用“isKindOfClass:”这样的类型信息查询方法，那么代理对象就会把这条消息转给“接受代理的对象”（proxied object）。也就是说，这条消息的返回值与直接在接受代理的对象上面查询其类型所得的结果相同。因此，这样查出来的类对象与通过class方法所返回的那个类对象不同，class方法所返回的类表示发起代理的对象，而非接受代理的对象。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 07 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/07/Effective-Objective-C-2.0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-14-%E7%90%86%E8%A7%A3-%E7%B1%BB%E5%AF%B9%E8%B1%A1-%E7%9A%84%E7%94%A8%E6%84%8F.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/07/Effective-Objective-C-2.0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-14-%E7%90%86%E8%A7%A3-%E7%B1%BB%E5%AF%B9%E8%B1%A1-%E7%9A%84%E7%94%A8%E6%84%8F.html</guid>
        
        <category>iOS</category>
        
        <category>Effective Objective-C 2.0</category>
        
        
      </item>
    
  </channel>
</rss>
