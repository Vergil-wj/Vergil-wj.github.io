<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Effective Objective-C 2.0 第一章 熟悉 Objective-C</title>
  <meta name="description" content="一、了解 Objective-C 语言的起源">
  <meta name="author" content="leopardpan">

  <!-- <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Effective Objective-C 2.0 第一章 熟悉 Objective-C">
  <meta name="twitter:description" content="一、了解 Objective-C 语言的起源"> -->
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="Effective Objective-C 2.0 第一章 熟悉 Objective-C">
  <meta property="og:description" content="一、了解 Objective-C 语言的起源">
  
  <link rel="icon" type="image/png" href="/images/favicon.png" />
  <link href="/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2019/04/24/Effective-Objective-C-2.0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%86%9F%E6%82%89-Objective-C.html">
  <link rel="alternate" type="application/rss+xml" title="Vergil" href="http://localhost:4000/feed.xml">
  
  <!-- <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" /> -->



</head>


  <body>

    <span class="mobile btn-mobile-menu">        
      <div class="nav_container">
         <nav class="nav-menu-item" style = "float:right">
            <i class="nav-menu-item">
              <a href="/#blog" title="" class="blog-button">  博客主页
              </a>
            </i>
            
                <i class="nav-menu-item">

                  <a href="/archive" title="archive" class="btn-mobile-menu__icon">
                      所有文章
                  </a>
                </i>
            
                <i class="nav-menu-item">

                  <a href="/tags" title="tags" class="btn-mobile-menu__icon">
                      标签
                  </a>
                </i>
            
          </nav>
      </div>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
        <div class="panel-main__content">
            <!-- 头像效果-start -->
            <div class="ih-item circle effect right_to_left">            
                <a href="/#blog" title="前往 Vergil 的主页" class="blog-button">
                    <div class="img"><img src="/images/avatar.jpg" alt="img"></div>
                    <div class="info">
                        <div class="info-back">
                            <h2> 
                                
                                Vergil
                                
                            </h2>
                            <p>
                             
                             iOS
                             
                         </p>
                     </div>
                 </div>
             </a>
         </div>
         <!-- 头像效果-end -->
         <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Vergil" class="blog-button">Vergil</a></h1>

         
         <span class="panel-cover__subtitle panel-subtitle">iOS 开发者</span>
         

         <hr class="panel-cover__divider" />
         <p class="panel-cover__description">我用双手成就你的梦想！</p>
         <hr class="panel-cover__divider panel-cover__divider--secondary" />

         


         <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">博客主页</a></li>
                
                <li class="navigation__item"><a href="/archive" title="archive">所有文章</a></li>
                
                <li class="navigation__item"><a href="/tags" title="tags">标签</a></li>
                
            </ul>
        </nav>
    </div>          
</div>


</div>
</div>
</div>


<div class="panel-cover--overlay cover-clear"></div>

</div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title">Effective Objective-C 2.0 第一章 熟悉 Objective-C</h1>
    <div class="post-meta"> 
      <time datetime="2019-04-24 00:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2019-04-24</time>  
    </div>
  </header>

  <section class="post">
    <h2 id="一了解-objective-c-语言的起源">一、了解 Objective-C 语言的起源</h2>

<p>Objective-C 与 C++、Java 等类似，是一种面向对象的语言。该语言使用“消息结构”而非“函数调用”。Objective-C 语言由 Smalltalk 演化而来，后者是消息型语言的鼻祖。</p>

<p>Objctive-C 为 C 语言添加了面向对象的特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接受一条消息之后，究竟应该执行何种代码，由运行期环境而非编译器来决定。</p>

<h2 id="二在类的头文件中尽量少引用其他头文件">二、在类的头文件中尽量少引用其他头文件</h2>

<p>在类的头文件 .h 中,如果需要引用其它类，尽可能少用 <code class="highlighter-rouge">#import</code> 改而使用 <code class="highlighter-rouge">@class</code>,在 实现文件 .m 中若要使用该类再使用 <code class="highlighter-rouge">#import</code> 。这样做是将引入头文件的时机尽量延后，只在确有需要时才引入，这样就可以减少类的使用者所需引入的头文件数量，从而减少编译时间。</p>

<h3 id="importincludeclass区别">#import、#include、@class区别：</h3>

<h4 id="include">#include:</h4>

<blockquote>
  <p>1、在C语言中，我们使用 #include 来引入头文件。</p>

  <p>2、#include 会造成重复引用头文件。</p>

  <p>3、为了防止重复引用可采用：</p>

  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```
#ifndef  ViewController_h

#define ViewController_h

#endif
```
</code></pre></div>  </div>
</blockquote>

<h4 id="import">#import:</h4>

<blockquote>
  <p>import 是 include 的升级版，可以防止重复引入头文件这种现象的发生。</p>

  <p>import会包含这个类的所有信息，包括实体变量和方法</p>

  <p>使用 #import 头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once</p>
</blockquote>

<h4 id="class">@class</h4>

<blockquote>
  <p>@class 用来告诉编译器，有这样一个类，使书写代码时，不报错。 但是  @class 只是使导入的类名在引用时不受影响，不能创建该类的对象，因为创建对象时也需要访问其内部方法。</p>
</blockquote>

<p>在编译效率方面考虑，如果你有100个头文件都 #import 了同一个头文件，或者这些文件是依次引用的，如 A–&gt;B, B–&gt;C, C–&gt;D 这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用 @class 则不会。</p>

<p>但是也有一些情况，是不可避免要在 .h 里引用的。比如：继承某个类，必须在 .h 里 import 父类的 .h；类实现某个接口，必须在 .h 里引用接口的 .h 等等</p>

<h2 id="三多用字面量语法少用与之等价的方法">三、多用字面量语法，少用与之等价的方法</h2>

<p>字面量字符串：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *someStr = @"someStr";
</code></pre></div></div>

<p>字面数值：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSNumber *intNum = @1;
NSNumber *boolNum = @YES;
NSNumber *charNum = @'a';
</code></pre></div></div>

<p>字面量数组：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSArray *animale = @[@"cat",@"dog",@"mouse"];
</code></pre></div></div>

<p>使用字面量数组的好处是，当数组元素对象中有 nil，则会抛出异常。因为字面量语法实际上是一种“语法糖”，其效果等于先是创建了一个数组，然后把方括号内的所有对象都加到这个数组中。</p>

<p>下面这段代码分别以两种语法创建数组：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSArray *arrayA = [NSArray arrayWithObjects:obj1,obj2,obj3, nil];
NSArray *arrayB = @[obj1,obj2,obj3];
</code></pre></div></div>

<p>假如 obj1 与 obj3 都指向了有效的 Objective-C 对象，而 obj2 为 nil，则字面量语法创建的数组 arrayB 会抛出异常。而 arrayA 虽然能够创建出来，但是其中却只含有 obj1 一个对象。原因在于<code class="highlighter-rouge">arrayWithObjects </code>方法会依次处理各个参数，之道发现 nil 为止，由于 obj2 是 nil，所以给方法会提前结束。</p>

<p>所以使用字面量语法更为安全，向数组中插入 nil 通常说明程序有错，而通过异常可以更快的发现这个错误。</p>

<p>字面量字典：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSDictionary *personData = @{
                                 @"name":@"matt",
                                 @"age":@28
                                 };
</code></pre></div></div>

<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的，若想变成可变的版本的对象，则需复制一份：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSMutableArray *mutable = @[@1,@2,@3].mutableCopy;
</code></pre></div></div>

<h2 id="四多用类型常量少用-define-宏预处理指令">四、多用类型常量，少用 #define (宏)预处理指令</h2>

<p>我们定义常量一般会使用宏 #define：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define ANIMATION_DURATION 0.3
</code></pre></div></div>

<p>这样定义出来的常量不含类型信息，编译器只是会在编译前据此查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。</p>

<p>在实现文件 .m 中我们应该使用类型常量来定义常量：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>staic const NSTimeInterval kAnimationDuration = 0.3;
</code></pre></div></div>

<p>在实现文件 .m 中，定义常量名称前面一般加字母 k。若在 .h 中,即常量在类之外可见，通常以类名为前缀:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//.h 中声明：
extern const NSTimeInterval EOCAnimationDuration; 

//.m 中实现：
const NSTimeInterval EOCAnimationDuration = 1.0; 
</code></pre></div></div>

<p>在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应该加以区隔，通常用与之相关的类名做前缀。</p>

<h3 id="defineconststaticextern区别">#define、const、static、extern区别</h3>

<h4 id="1define-宏">1、define 宏：</h4>

<ul>
  <li>编译时刻：宏是预编译（编译之前处理），const是编译阶段。</li>
  <li>编译检查：宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
  <li>宏的好处：宏能定义一些函数，方法。 const不能。</li>
  <li>宏的坏处：使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>

<h4 id="2const">2、const:</h4>

<p>中文“常量”意思。</p>

<ul>
  <li>const用来修饰右边的基本变量或指针变量。</li>
  <li>被修饰的变量只读，不能被修改。</li>
</ul>

<p>看下面的例子，相信你就完全理解 const 的用法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int const *p   // *p只读，p变量
int * const p  // *p变量，p只读
const int * const p //p和*p都只读
int const * const p //p和*p都只读
</code></pre></div></div>

<h4 id="3static">3、static</h4>

<p>中文“静态”意思。</p>

<p>#####（1）修饰局部变量</p>

<p>保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存，  生命周期类似全局变量了，但是作用域不变。例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{
    
    static int i =0;
    i++;
    NSLog(@"i = %d",i);
}
</code></pre></div></div>

<p>得到的结果是变量 i 每次都会自增。如果不使用 static 修饰，则 i 每次结果只为 1。这就是关键字 static 修饰的局部变量的作用，让局部变量永远只初始化一次，一份内存，生命周期已经跟全局变量类似了，只是作用域不变。</p>

<p>#####（2）修饰全局变量</p>

<p>使全局变量的作用域仅限于当前文件内部，即当前文件内部才能访问该全局变量。</p>

<p>iOS 中在一个文件声明的全局变量，工程的其他文件也是能访问的，但是我又不想让其他文件访问，这时就可以用 static 修饰它了。</p>

<p>#####（3）修饰函数</p>

<p>static 修饰函数时，被修饰的函数被称为静态函数，使得外部文件无法访问这个函数，仅本文件可以访问。这个在 oc 语言开发中几乎很少用，c 语言倒是能看到一些影子，所以不详细探讨。</p>

<h4 id="4extern">4、extern</h4>

<p>中文“外部的”意思。它的作用是声明外部全局变量。这里需要特别注意extern只能声明，不能用于实现。</p>

<p>在开发中，我们通常会单独抽一个类来管理一些全局的变量或常量，下面来看看逼格比较高的一种做法：</p>

<p>我们可以在.h文件中 extern 声明一些全局的常量:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern NSString * const name;
extern NSInteger const count;
</code></pre></div></div>

<p>.m 中实现</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString * const name = @"王五";
NSInteger const count = 3;
</code></pre></div></div>

<p>这样，只要导入头文件，就可以全局的使用定义的变量或常量。</p>

<h2 id="五用枚举表示状态选项状态码">五、用枚举表示状态、选项、状态码</h2>

<p>枚举是一种常量命名方式。</p>

<h3 id="枚举表示状态状态码同理">枚举表示状态（状态码同理）</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//第一种写法，先定义枚举类型，再定义枚举变量
enum EOCConnetionState{
    EOCConnetionStateDisconnected,
    EOCConnetionStateConnecting,
    EOCConnetionStateConnected
};
enum EOCConnetionState state;

//第二种写法，定义枚举类型的同时定义枚举变量
enum EOCConnetionState{
    EOCConnetionStateDisconnected,
    EOCConnetionStateConnecting,
    EOCConnetionStateConnected
}state;
</code></pre></div></div>

<p>由于每种状态都用一个便于理解的值来表示，所以这样写出来的代码更易读懂。</p>

<h3 id="枚举表示选项">枚举表示选项</h3>

<p>一个“选项变量”的类型要能够同时表示一个或多个组合的选择，如下例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum TTGDirection {
    TTGDirectionNone = 0,
    TTGDirectionTop = 1 &lt;&lt; 0,    //00000001
    TTGDirectionLeft = 1 &lt;&lt; 1,   //00000010
    TTGDirectionRight = 1 &lt;&lt; 2,  //00000100
    TTGDirectionBottom = 1 &lt;&lt; 3  //00001000
};
</code></pre></div></div>

<p>这里的选项是用位运算的方式定义的，这样的好处就是，我们的选项变量可以如下表示：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//用“或”运算同时赋值多个选项
enum TTGDirection direction = TTGDirectionTop | TTGDirectionLeft | TTGDirectionBottom;

//用“与”运算取出对应位
if (direction &amp; TTGDirectionTop) {
    NSLog(@"top");
}
if (direction &amp; TTGDirectionLeft) {
    NSLog(@"left");
}
if (direction &amp; TTGDirectionRight) {
    NSLog(@"right");
}
if (direction &amp; TTGDirectionBottom) {
    NSLog(@"bottom");
}
</code></pre></div></div>

<p>direction变量的实际内存如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 0 0 0 1 0 1 1
</code></pre></div></div>

<p>控制台输出：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top
left
bottom
</code></pre></div></div>

<p>这样，用位运算，就可以同时支持多个值。</p>

<h4 id="enum在-objective-c-中的升级版">enum在 Objective-C 中的“升级版”</h4>

<p>一般来说，我们不能指定枚举变量的实际类型是什么，就是说，我们不知道枚举最后是 int 型，还是其他的什么类型。但是从 C++ 11开始，我们可以为枚举指定其实际的存储类型，如下语法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum TTGState : NSInteger {/*...*/};
</code></pre></div></div>

<p>但是，我们在定义枚举的时候如何保证兼容性呢？Foundation 框架已经为我们提供了更加“统一、便捷”的枚举定义方法，如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//NS_ENUM，定义状态等普通枚举
typedef NS_ENUM(NSUInteger, TTGState) {
    TTGStateOK = 0,
    TTGStateError,
    TTGStateUnknow
};

//NS_OPTIONS，定义选项
typedef NS_OPTIONS(NSUInteger, TTGDirection) {
    TTGDirectionNone = 0,
    TTGDirectionTop = 1 &lt;&lt; 0,
    TTGDirectionLeft = 1 &lt;&lt; 1,
    TTGDirectionRight = 1 &lt;&lt; 2,
    TTGDirectionBottom = 1 &lt;&lt; 3
};
</code></pre></div></div>

<p>所以，在 iOS 开发中，枚举最好使用<code class="highlighter-rouge">NS_ENUM</code>和<code class="highlighter-rouge">NS_OPTIONS</code>定义，并指明其底层数据类型，保证统一。</p>

<h3 id="处理枚举类型-switch-语句中不要实现-default-分支">处理枚举类型 switch 语句中不要实现 default 分支</h3>

<p>这样的话，加入新枚举之后，编译器就会提示开发者 switch 语句并未处理所有枚举。如果写上了 default 分支，那么它就会处理这个新状态，从而导致编译器不发警告信息。</p>

<h2 id="参考资料">参考资料</h2>

<p>1、Effective Objective-C 2.0</p>

<p>2、<a href="https://juejin.im/post/5aaf6943518825556e5de48e">https://juejin.im/post/5aaf6943518825556e5de48e</a></p>

<p>3、<a href="http://www.cocoachina.com/ios/20161110/18035.html">http://www.cocoachina.com/ios/20161110/18035.html</a></p>

<p>4、<a href="https://www.cnblogs.com/feiyu-mdm/p/6392493.html">https://www.cnblogs.com/feiyu-mdm/p/6392493.html</a></p>


  </section>

</article>

<section>

  <div style="text-align:center;margin:50px 0; font:normal 14px/24px 'MicroSoft YaHei';"></div>

  <ul class="pager">
    
    <li class="previous">
      <a href="/2019/04/23/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" data-toggle="tooltip" data-placement="top" title="iOS 生命周期">上一篇：  <span>iOS 生命周期</span>
      </a>
    </li>
    
    
    <li class="next">
      <a href="/2019/04/28/CSS%E4%B8%AD-px-em-rem.html" data-toggle="tooltip" data-placement="top" title="css 中 font-size:62.5% 与 px em rem">下一篇：  <span>css 中 font-size:62.5% 与 px em rem</span>
      </a>
    </li>
    
  </ul>
</section>


            <section class="footer">
  <footer>
    <div class = "footer_div">  
      <nav class="cover-navigation navigation--social">
        <ul class="navigation">

          
          <!-- Github -->
          <li class="navigation__item_social">
            <a href="https://github.com/Vergil-wj" title="@Vergil-wj 的 Github" target="_blank">
              <div class="footer-social-icon" style="background:url(/images/github.png);"></div>
            </a>
          </li>
          

          
          <li class="navigation__item_social">
            <a href="https://www.jianshu.com/u/3e3ba42c4c63" title="@3e3ba42c4c63" target="_blank">
              <div class="footer-social-icon" style="background:url(/images/jianshu.jpg);"></div>
            </a>
          </li>

          

          
          <!-- Email -->
          <li class="navigation__item_social">
            <a href="mailto:834372189@qq.com" title="Contact me">
              <div class="footer-social-icon" style="background:url(/images/email.png);"></div>
            </a>
          </li>
          
          
        </ul>
      </nav>

    </div>

    <div class = "footer_div">  

      <div align="center">
        <p class="copyright text-muted">
          Copyright &copy; Vergil 2019
        </p>
        <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
      </div>

    </div>
  </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



    
  </body>

</html>
